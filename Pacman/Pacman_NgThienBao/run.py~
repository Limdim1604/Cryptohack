import pygame
from pygame.locals import *
from constants import *
from pacman import Pacman
from nodes import NodeGroup
from pellets import PelletGroup
from ghosts import GhostGroup
from fruit import Fruit
from pauser import Pause
from text import TextGroup
from sprites import LifeSprites
from sprites import MazeSprites
#from mazes import MazenController
from mazedata import MazeData######

class GameController(object):
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode(SCREENSIZE, 0, 32)
        self.background = None
        self.background_norm = None
        self.background_flash = None
        self.clock = pygame.time.Clock()
        self.fruit = None
        self.pause = Pause(True)
        self.level = 0
        self.lives = 5
        self.score = 0
        self.textgroup = TextGroup()
        self.lifesprites = LifeSprites(self.lives)
        self.flashBG = False
        self.flashTime = 0.2
        self.flashTimer = 0
        self.fruitCaptured = []
        self.fruitNode = None
        #self.maze = MazeController()
        self.mazedata = MazeData()######

    def setBackground(self):
        self.background_norm = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_norm.fill(BLACK)
        self.background_flash = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_flash.fill(BLACK)
        self.background_norm = self.mazesprites.constructBackground(self.background_norm, self.level%5)
        self.background_flash = self.mazesprites.constructBackground(self.background_flash, 5)
        self.flashBG = False
        self.background = self.background_norm

    def startGame(self):      
        self.mazedata.loadMaze(self.level)
        self.mazesprites = MazeSprites(self.mazedata.obj.name+".txt", self.mazedata.obj.name+"_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup(self.mazedata.obj.name+".txt")
        self.mazedata.obj.setPortalPairs(self.nodes)
        self.mazedata.obj.connectHomeNodes(self.nodes)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(*self.mazedata.obj.pacmanStart))
        self.pellets = PelletGroup(self.mazedata.obj.name+".txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)

        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(0, 3)))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(4, 3)))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 0)))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.mazedata.obj.denyGhostsAccess(self.ghosts, self.nodes)

    def startGame_old(self):      
        self.mazedata.loadMaze(self.level)#######
        self.mazesprites = MazeSprites("maze1.txt", "maze1_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("maze1.txt")
        self.nodes.setPortalPair((0,17), (27,17))
        homekey = self.nodes.createHomeNodes(11.5, 14)
        self.nodes.connectHomeNodes(homekey, (12,14), LEFT)
        self.nodes.connectHomeNodes(homekey, (15,14), RIGHT)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(15, 26))
        self.pellets = PelletGroup("maze1.txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 0+14))
        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(0+11.5, 3+14))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(4+11.5, 3+14))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, LEFT, self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, RIGHT, self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.nodes.denyAccessList(12, 14, UP, self.ghosts)
        self.nodes.denyAccessList(15, 14, UP, self.ghosts)
        self.nodes.denyAccessList(12, 26, UP, self.ghosts)
        self.nodes.denyAccessList(15, 26, UP, self.ghosts)

        

    def update(self):
        dt = self.clock.tick(30) / 1000.0
        self.textgroup.update(dt)
        self.pellets.update(dt)
        if not self.pause.paused:
            self.ghosts.update(dt)      
            if self.fruit is not None:
                self.fruit.update(dt)
            self.checkPelletEvents()
            self.checkGhostEvents()
            self.checkFruitEvents()

        if self.pacman.alive:
            if not self.pause.paused:
                self.pacman.update(dt)
        else:
            self.pacman.update(dt)

        if self.flashBG:
            self.flashTimer += dt
            if self.flashTimer >= self.flashTime:
                self.flashTimer = 0
                if self.background == self.background_norm:
                    self.background = self.background_flash
                else:
                    self.background = self.background_norm

        afterPauseMethod = self.pause.update(dt)
        if afterPauseMethod is not None:
            afterPauseMethod()
        self.checkEvents()
        self.render()

    def checkEvents(self):
        for event in pygame.event.get():
            if event.type == QUIT:
                exit()
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    if self.pacman.alive:
                        self.pause.setPause(playerPaused=True)
                        if not self.pause.paused:
                            self.textgroup.hideText()
                            self.showEntities()
                        else:
                            self.textgroup.showText(PAUSETXT)
                            #self.hideEntities()

    def checkPelletEvents(self):
        pellet = self.pacman.eatPellets(self.pellets.pelletList)
        if pellet:
            self.pellets.numEaten += 1
            self.updateScore(pellet.points)
            if self.pellets.numEaten == 30:
                self.ghosts.inky.startNode.allowAccess(RIGHT, self.ghosts.inky)
            if self.pellets.numEaten == 70:
                self.ghosts.clyde.startNode.allowAccess(LEFT, self.ghosts.clyde)
            self.pellets.pelletList.remove(pellet)
            if pellet.name == POWERPELLET:
                self.ghosts.startFreight()
            if self.pellets.isEmpty():
                self.flashBG = True
                self.hideEntities()
                self.pause.setPause(pauseTime=3, func=self.nextLevel)

    def checkGhostEvents(self):
        for ghost in self.ghosts:
            if self.pacman.collideGhost(ghost):
                if ghost.mode.current is FREIGHT:
                    self.pacman.visible = False
                    ghost.visible = False
                    self.updateScore(ghost.points)                  
                    self.textgroup.addText(str(ghost.points), WHITE, ghost.position.x, ghost.position.y, 8, time=1)
                    self.ghosts.updatePoints()
                    self.pause.setPause(pauseTime=1, func=self.showEntities)
                    ghost.startSpawn()
                    self.nodes.allowHomeAccess(ghost)
                elif ghost.mode.current is not SPAWN:
                    if self.pacman.alive:
                        self.lives -=  1
                        self.lifesprites.removeImage()
                        self.pacman.die()               
                        self.ghosts.hide()
                        if self.lives <= 0:
                            self.textgroup.showText(GAMEOVERTXT)
                            self.pause.setPause(pauseTime=3, func=self.restartGame)
                        else:
                            self.pause.setPause(pauseTime=3, func=self.resetLevel)
    
    def checkFruitEvents(self):
        if self.pellets.numEaten == 50 or self.pellets.numEaten == 140:
            if self.fruit is None:
                self.fruit = Fruit(self.nodes.getNodeFromTiles(9, 20), self.level)
                print(self.fruit)
        if self.fruit is not None:
            if self.pacman.collideCheck(self.fruit):
                self.updateScore(self.fruit.points)
                self.textgroup.addText(str(self.fruit.points), WHITE, self.fruit.position.x, self.fruit.position.y, 8, time=1)
                fruitCaptured = False
                for fruit in self.fruitCaptured:
                    if fruit.get_offset() == self.fruit.image.get_offset():
                        fruitCaptured = True
                        break
                if not fruitCaptured:
                    self.fruitCaptured.append(self.fruit.image)
                self.fruit = None
            elif self.fruit.destroy:
                self.fruit = None

    def showEntities(self):
        self.pacman.visible = True
        self.ghosts.show()

    def hideEntities(self):
        self.pacman.visible = False
        self.ghosts.hide()

    def nextLevel(self):
        self.showEntities()
        self.level += 1
        self.pause.paused = True
        self.startGame()
        self.textgroup.updateLevel(self.level)

    def restartGame(self):
        self.lives = 5
        self.level = 0
        self.pause.paused = True
        self.fruit = None
        self.startGame()
        self.score = 0
        self.textgroup.updateScore(self.score)
        self.textgroup.updateLevel(self.level)
        self.textgroup.showText(READYTXT)
        self.lifesprites.resetLives(self.lives)
        self.fruitCaptured = []

    def resetLevel(self):
        self.pause.paused = True
        self.pacman.reset()
        self.ghosts.reset()
        self.fruit = None
        self.textgroup.showText(READYTXT)

    def updateScore(self, points):
        self.score += points
        self.textgroup.updateScore(self.score)

    def render(self):
        self.screen.blit(self.background, (0, 0))
        #self.nodes.render(self.screen)
        self.pellets.render(self.screen)
        if self.fruit is not None:
            self.fruit.render(self.screen)
        self.pacman.render(self.screen)
        self.ghosts.render(self.screen)
        self.textgroup.render(self.screen)

        for i in range(len(self.lifesprites.images)):
            x = self.lifesprites.images[i].get_width() * i
            y = SCREENHEIGHT - self.lifesprites.images[i].get_height()
            self.screen.blit(self.lifesprites.images[i], (x, y))

        for i in range(len(self.fruitCaptured)):
            x = SCREENWIDTH - self.fruitCaptured[i].get_width() * (i+1)
            y = SCREENHEIGHT - self.fruitCaptured[i].get_height()
            self.screen.blit(self.fruitCaptured[i], (x, y))

        pygame.display.update()


if __name__ == "__main__":
    game = GameController()
    game.startGame()
    while True:
        game.update()

///////////////////////////
///////////////////////////
///////////////////////////
///////////////////////////

import pygame
from pygame.locals import *
from constants import *
from pacman import Pacman
from nodes import NodeGroup
from pellets import PelletGroup
from ghosts import GhostGroup
from fruit import Fruit
from pauser import Pause
from text import TextGroup
from sprites import LifeSprites
from sprites import MazeSprites
from mazedata import MazeData

class GameController(object):
    def __init__(self):
        pygame.init()
        pygame.mixer.init()
        pygame.mixer.music.load("Pacman_NgThienBao/BTS_FAKELOVE.mp3")
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3") 
        pygame.mixer.music.play(-1)
        self.screen = pygame.display.set_mode(SCREENSIZE, 0, 32)
        self.background = None
        self.background_norm = None
        self.background_flash = None
        self.clock = pygame.time.Clock()
        self.fruit = None
        self.pause = Pause(True)
        self.level = 0
        self.lives = 10
        self.score = 0
        self.textgroup = TextGroup()
        self.lifesprites = LifeSprites(self.lives)
        self.flashBG = False
        self.flashTime = 0.2
        self.flashTimer = 0
        self.fruitCaptured = []
        self.fruitNode = None
        self.mazedata = MazeData()
        
    
        

    def setBackground(self):
        self.background_norm = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_norm.fill(BLACK)
        self.background_flash = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_flash.fill(BLACK)
        self.background_norm = self.mazesprites.constructBackground(self.background_norm, self.level%5)
        self.background_flash = self.mazesprites.constructBackground(self.background_flash, 5)
        self.flashBG = False
        self.background = self.background_norm
    
    
    def startScreen(self):
        self.running = True
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        return

            self.screen.fill((0, 250, 255))
            font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 30)
            # text = font.render("Press Space to Start", 1, (255, 255, 255))
            # textpos = text.get_rect(centerx=self.screen.get_width()/2)
            # self.screen.blit(text, textpos)
            
            instructions = ["ĐỒ ÁN CUỐI KỲ","Nguyễn Thiên Bảo","Hãy giữ nút mũi tên để chơi","Nhấn Space để chơi và dừng"]
            for i, instruction in enumerate(instructions):
                instruction_text = font.render(instruction, 1, (255, 20, 100))
                instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/5 + 60 * (i+1))
                self.screen.blit(instruction_text, instruction_pos)
            
            pygame.display.flip()
            
        self.startGame()
    


    def startGame(self):      
        self.mazedata.loadMaze(self.level)
        self.mazesprites = MazeSprites(self.mazedata.obj.name+".txt", self.mazedata.obj.name+"_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.mazedata.obj.setPortalPairs(self.nodes)
        self.mazedata.obj.connectHomeNodes(self.nodes)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(*self.mazedata.obj.pacmanStart))
        self.pellets = PelletGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)

        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(0, 3)))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(4, 3)))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 0)))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.mazedata.obj.denyGhostsAccess(self.ghosts, self.nodes)

    def startGame_old(self):      
        self.mazedata.loadMaze(self.level)#######
        self.mazesprites = MazeSprites("maze1.txt", "maze1_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("maze1.txt")
        self.nodes.setPortalPair((0,17), (27,17))
        homekey = self.nodes.createHomeNodes(11.5, 14)
        self.nodes.connectHomeNodes(homekey, (12,14), LEFT)
        self.nodes.connectHomeNodes(homekey, (15,14), RIGHT)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(15, 26))
        self.pellets = PelletGroup("maze1.txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 0+14))
        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(0+11.5, 3+14))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(4+11.5, 3+14))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, LEFT, self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, RIGHT, self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.nodes.denyAccessList(12, 14, UP, self.ghosts)
        self.nodes.denyAccessList(15, 14, UP, self.ghosts)
        self.nodes.denyAccessList(12, 26, UP, self.ghosts)
        self.nodes.denyAccessList(15, 26, UP, self.ghosts)

        

    def update(self):
        dt = self.clock.tick(30) / 1000.0
        self.textgroup.update(dt)
        self.pellets.update(dt)
        if not self.pause.paused:
            self.ghosts.update(dt)      
            if self.fruit is not None:
                self.fruit.update(dt)
            self.checkPelletEvents()
            self.checkGhostEvents()
            self.checkFruitEvents()

        if self.pacman.alive:
            if not self.pause.paused:
                self.pacman.update(dt)
        else:
            self.pacman.update(dt)

        if self.flashBG:
            self.flashTimer += dt
            if self.flashTimer >= self.flashTime:
                self.flashTimer = 0
                if self.background == self.background_norm:
                    self.background = self.background_flash
                else:
                    self.background = self.background_norm

        afterPauseMethod = self.pause.update(dt)
        if afterPauseMethod is not None:
            afterPauseMethod()
        self.checkEvents()
        self.render()

    def checkEvents(self):
        for event in pygame.event.get():
            if event.type == QUIT:
                exit()
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    if self.pacman.alive:
                        self.pause.setPause(playerPaused=True)
                        if not self.pause.paused:
                            self.textgroup.hideText()
                            self.showEntities()
                        else:
                            self.textgroup.showText(PAUSETXT)
                            #self.hideEntities()

    def checkPelletEvents(self):
        pellet = self.pacman.eatPellets(self.pellets.pelletList)
        if pellet:
            self.pellets.numEaten += 1
            self.updateScore(pellet.points)
            if self.pellets.numEaten == 30:
                self.ghosts.inky.startNode.allowAccess(RIGHT, self.ghosts.inky)
            if self.pellets.numEaten == 70:
                self.ghosts.clyde.startNode.allowAccess(LEFT, self.ghosts.clyde)
            self.pellets.pelletList.remove(pellet)
            if pellet.name == POWERPELLET:
                self.ghosts.startFreight()
            if self.pellets.isEmpty():
                self.flashBG = True
                self.hideEntities()
                self.pause.setPause(pauseTime=3, func=self.nextLevel)

    def checkGhostEvents(self):
        for ghost in self.ghosts:
            if self.pacman.collideGhost(ghost):
                if ghost.mode.current is FREIGHT:
                    self.pacman.visible = False
                    ghost.visible = False
                    self.updateScore(ghost.points)                  
                    self.textgroup.addText(str(ghost.points), WHITE, ghost.position.x, ghost.position.y, 8, time=1)
                    self.ghosts.updatePoints()
                    self.pause.setPause(pauseTime=1, func=self.showEntities)
                    ghost.startSpawn()
                    self.nodes.allowHomeAccess(ghost)
                elif ghost.mode.current is not SPAWN:
                    if self.pacman.alive:
                        self.lives -=  1
                        self.lifesprites.removeImage()
                        self.pacman.die()               
                        self.ghosts.hide()
                        if self.lives <= 0:
                            self.textgroup.showText(GAMEOVERTXT)
                            self.pause.setPause(pauseTime=3, func=self.restartGame)
                        else:
                            self.pause.setPause(pauseTime=3, func=self.resetLevel)
    
    def checkFruitEvents(self):
        if self.pellets.numEaten == 50 or self.pellets.numEaten == 140:
            if self.fruit is None:
                self.fruit = Fruit(self.nodes.getNodeFromTiles(9, 20), self.level)
                print(self.fruit)
        if self.fruit is not None:
            if self.pacman.collideCheck(self.fruit):
                self.updateScore(self.fruit.points)
                self.textgroup.addText(str(self.fruit.points), WHITE, self.fruit.position.x, self.fruit.position.y, 8, time=1)
                fruitCaptured = False
                for fruit in self.fruitCaptured:
                    if fruit.get_offset() == self.fruit.image.get_offset():
                        fruitCaptured = True
                        break
                if not fruitCaptured:
                    self.fruitCaptured.append(self.fruit.image)
                self.fruit = None
            elif self.fruit.destroy:
                self.fruit = None

    def showEntities(self):
        self.pacman.visible = True
        self.ghosts.show()

    def hideEntities(self):
        self.pacman.visible = False
        self.ghosts.hide()

    def nextLevel(self):
        self.showEntities()
        self.level += 1
        self.pause.paused = True
        self.startGame()
        self.textgroup.updateLevel(self.level)

    def restartGame(self):
        self.lives = 10
        self.level = 0
        self.pause.paused = True
        self.fruit = None
        self.startGame()
        self.score = 0
        self.textgroup.updateScore(self.score)
        self.textgroup.updateLevel(self.level)
        self.textgroup.showText(READYTXT)
        self.lifesprites.resetLives(self.lives)
        self.fruitCaptured = []

    def resetLevel(self):
        self.pause.paused = True
        self.pacman.reset()
        self.ghosts.reset()
        self.fruit = None
        self.textgroup.showText(READYTXT)

    def updateScore(self, points):
        self.score += points
        self.textgroup.updateScore(self.score)

    def render(self):
        self.screen.blit(self.background, (0, 0))
        #self.nodes.render(self.screen)
        self.pellets.render(self.screen)
        if self.fruit is not None:
            self.fruit.render(self.screen)
        self.pacman.render(self.screen)
        self.ghosts.render(self.screen)
        self.textgroup.render(self.screen)

        for i in range(len(self.lifesprites.images)):
            x = self.lifesprites.images[i].get_width() * i
            y = SCREENHEIGHT - self.lifesprites.images[i].get_height()
            self.screen.blit(self.lifesprites.images[i], (x, y))

        for i in range(len(self.fruitCaptured)):
            x = SCREENWIDTH - self.fruitCaptured[i].get_width() * (i+1)
            y = SCREENHEIGHT - self.fruitCaptured[i].get_height()
            self.screen.blit(self.fruitCaptured[i], (x, y))

        pygame.display.update()


if __name__ == "__main__":
    game = GameController()
    game.startScreen()
    game.startGame()
    
    while game.running:   
        game.update()
        

/////////////////////////////
/////////////////////////
////////////////////////////     
/////////////////////////
import pygame
from pygame.locals import *
from constants import *
from pacman import Pacman
from nodes import NodeGroup
from pellets import PelletGroup
from ghosts import GhostGroup
from fruit import Fruit
from pauser import Pause
from text import TextGroup
from sprites import LifeSprites
from sprites import MazeSprites
from mazedata import MazeData

class GameController(object):
    def __init__(self):
        pygame.init()
        pygame.mixer.init()
        pygame.mixer.music.load("Pacman_NgThienBao/BTS_FAKELOVE.mp3")
        # pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3") 
        pygame.mixer.music.play(-1)
        self.screen = pygame.display.set_mode(SCREENSIZE, 0, 32)
        self.background = None
        self.background_norm = None
        self.background_flash = None
        self.clock = pygame.time.Clock()
        self.fruit = None
        self.pause = Pause(True)
        self.level = 0
        self.lives = 10
        self.score = 0
        self.textgroup = TextGroup()
        self.lifesprites = LifeSprites(self.lives)
        self.flashBG = False
        self.flashTime = 0.2
        self.flashTimer = 0
        self.fruitCaptured = []
        self.fruitNode = None
        self.mazedata = MazeData()
        
    
        

    def setBackground(self):
        self.background_norm = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_norm.fill(OPTIONAL)
        self.background_flash = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_flash.fill(BLACK)
        self.background_norm = self.mazesprites.constructBackground(self.background_norm, self.level%5)
        self.background_flash = self.mazesprites.constructBackground(self.background_flash, 5)
        self.flashBG = False
        self.background = self.background_norm
    
    
    def startScreen(self):
        self.running = True
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        return

            self.screen.fill((0, 250, 255))
            font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 30)
            # text = font.render("Press Space to Start", 1, (255, 255, 255))
            # textpos = text.get_rect(centerx=self.screen.get_width()/2)
            # self.screen.blit(text, textpos)
            
            instructions = ["ĐỒ ÁN CUỐI KỲ","Nguyễn Thiên Bảo","Hãy giữ nút mũi tên để chơi","Nhấn Space để chơi và dừng"]
            for i, instruction in enumerate(instructions):
                instruction_text = font.render(instruction, 1, (255, 20, 100))
                instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/5 + 60 * (i+1))
                self.screen.blit(instruction_text, instruction_pos)
            
            pygame.display.flip()
            
        self.startGame()
    


    def startGame(self):  
            
        self.mazedata.loadMaze(self.level)
        self.mazesprites = MazeSprites(self.mazedata.obj.name+".txt", self.mazedata.obj.name+"_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.mazedata.obj.setPortalPairs(self.nodes)
        self.mazedata.obj.connectHomeNodes(self.nodes)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(*self.mazedata.obj.pacmanStart))
        self.pellets = PelletGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)

        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(0, 3)))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(4, 3)))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 0)))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.mazedata.obj.denyGhostsAccess(self.ghosts, self.nodes)

    def startGame_old(self):      
        self.mazedata.loadMaze(self.level)#######
        self.mazesprites = MazeSprites("maze1.txt", "maze1_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("maze1.txt")
        self.nodes.setPortalPair((0,17), (27,17))
        homekey = self.nodes.createHomeNodes(11.5, 14)
        self.nodes.connectHomeNodes(homekey, (12,14), LEFT)
        self.nodes.connectHomeNodes(homekey, (15,14), RIGHT)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(15, 26))
        self.pellets = PelletGroup("maze1.txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 0+14))
        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(0+11.5, 3+14))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(4+11.5, 3+14))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, LEFT, self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, RIGHT, self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.nodes.denyAccessList(12, 14, UP, self.ghosts)
        self.nodes.denyAccessList(15, 14, UP, self.ghosts)
        self.nodes.denyAccessList(12, 26, UP, self.ghosts)
        self.nodes.denyAccessList(15, 26, UP, self.ghosts)

        

    def update(self):
        dt = self.clock.tick(30) / 800.0
        self.textgroup.update(dt)
        self.pellets.update(dt)
        if not self.pause.paused:
            self.ghosts.update(dt)      
            if self.fruit is not None:
                self.fruit.update(dt)
            self.checkPelletEvents()
            self.checkGhostEvents()
            self.checkFruitEvents()

        if self.pacman.alive:
            if not self.pause.paused:
                self.pacman.update(dt)
        else:
            self.pacman.update(dt)

        if self.flashBG:
            self.flashTimer += dt
            if self.flashTimer >= self.flashTime:
                self.flashTimer = 0
                if self.background == self.background_norm:
                    self.background = self.background_flash
                else:
                    self.background = self.background_norm

        afterPauseMethod = self.pause.update(dt)
        if afterPauseMethod is not None:
            afterPauseMethod()
        self.checkEvents()
        self.render()

    def checkEvents(self):
        for event in pygame.event.get():
            if event.type == QUIT:
                exit()
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    if self.pacman.alive:
                        self.pause.setPause(playerPaused=True)
                        if not self.pause.paused:
                            self.textgroup.hideText()
                            self.showEntities()
                        else:
                            self.textgroup.showText(PAUSETXT)
                            #self.hideEntities()

    def checkPelletEvents(self):
        pellet = self.pacman.eatPellets(self.pellets.pelletList)
        if pellet:
            self.pellets.numEaten += 1
            self.updateScore(pellet.points)
            if self.pellets.numEaten == 30:
                self.ghosts.inky.startNode.allowAccess(RIGHT, self.ghosts.inky)
            if self.pellets.numEaten == 70:
                self.ghosts.clyde.startNode.allowAccess(LEFT, self.ghosts.clyde)
            self.pellets.pelletList.remove(pellet)
            if pellet.name == POWERPELLET:
                self.ghosts.startFreight()
            if self.pellets.isEmpty():
                self.flashBG = True
                self.hideEntities()
                self.pause.setPause(pauseTime=3, func=self.nextLevel)

    def checkGhostEvents(self):
        for ghost in self.ghosts:
            if self.pacman.collideGhost(ghost):
                if ghost.mode.current is FREIGHT:
                    self.pacman.visible = False
                    ghost.visible = False
                    self.updateScore(ghost.points)                  
                    self.textgroup.addText(str(ghost.points), WHITE, ghost.position.x, ghost.position.y, 8, time=1)
                    self.ghosts.updatePoints()
                    self.pause.setPause(pauseTime=1, func=self.showEntities)
                    ghost.startSpawn()
                    self.nodes.allowHomeAccess(ghost)
                elif ghost.mode.current is not SPAWN:
                    if self.pacman.alive:
                        self.lives -=  1
                        self.lifesprites.removeImage()
                        self.pacman.die()               
                        self.ghosts.hide()
                        if self.lives <= 0:
                            self.textgroup.showText(GAMEOVERTXT)
                            self.pause.setPause(pauseTime=3, func=self.restartGame)
                        else:
                            self.pause.setPause(pauseTime=3, func=self.resetLevel)
    
    def checkFruitEvents(self):
        if self.pellets.numEaten == 50 or self.pellets.numEaten == 140:
            if self.fruit is None:
                self.fruit = Fruit(self.nodes.getNodeFromTiles(9, 20), self.level)
                print(self.fruit)
        if self.fruit is not None:
            if self.pacman.collideCheck(self.fruit):
                self.updateScore(self.fruit.points)
                self.textgroup.addText(str(self.fruit.points), WHITE, self.fruit.position.x, self.fruit.position.y, 8, time=1)
                fruitCaptured = False
                for fruit in self.fruitCaptured:
                    if fruit.get_offset() == self.fruit.image.get_offset():
                        fruitCaptured = True
                        break
                if not fruitCaptured:
                    self.fruitCaptured.append(self.fruit.image)
                self.fruit = None
            elif self.fruit.destroy:
                self.fruit = None

    def showEntities(self):
        self.pacman.visible = True
        self.ghosts.show()

    def hideEntities(self):
        self.pacman.visible = False
        self.ghosts.hide()

    def nextLevel(self):
        self.showEntities()
        self.level += 1
        self.pause.paused = True
        self.startGame()
        self.textgroup.updateLevel(self.level)

    def restartGame(self):
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3")
        pygame.mixer.music.play(1)
        self.lives = 10
        self.level = 0
        self.pause.paused = True
        self.fruit = None
        self.startGame()
        self.score = 0
        self.textgroup.updateScore(self.score)
        self.textgroup.updateLevel(self.level)
        self.textgroup.showText(READYTXT)
        self.lifesprites.resetLives(self.lives)
        self.fruitCaptured = []

    def resetLevel(self):
        self.pause.paused = True
        self.pacman.reset()
        self.ghosts.reset()
        self.fruit = None
        self.textgroup.showText(READYTXT)

    def updateScore(self, points):
        self.score += points
        self.textgroup.updateScore(self.score)

    def render(self):
        self.screen.blit(self.background, (0, 0))
        #self.nodes.render(self.screen)
        self.pellets.render(self.screen)
        if self.fruit is not None:
            self.fruit.render(self.screen)
        self.pacman.render(self.screen)
        self.ghosts.render(self.screen)
        self.textgroup.render(self.screen)

        for i in range(len(self.lifesprites.images)):
            x = self.lifesprites.images[i].get_width() * i
            y = SCREENHEIGHT - self.lifesprites.images[i].get_height()
            self.screen.blit(self.lifesprites.images[i], (x, y))

        for i in range(len(self.fruitCaptured)):
            x = SCREENWIDTH - self.fruitCaptured[i].get_width() * (i+1)
            y = SCREENHEIGHT - self.fruitCaptured[i].get_height()
            self.screen.blit(self.fruitCaptured[i], (x, y))

        pygame.display.update()


if __name__ == "__main__":
    game = GameController()
    game.startScreen()
    game.startGame()
    
    while game.running:   
        game.update()
        

//////////////////
/////////////////
////////////////////////
/////////////////////////
import pygame
from pygame.locals import *
from constants import *
from pacman import Pacman
from nodes import NodeGroup
from pellets import PelletGroup
from ghosts import GhostGroup
from fruit import Fruit
from pauser import Pause
from text import TextGroup
from sprites import LifeSprites
from sprites import MazeSprites
from mazedata import MazeData

class GameController(object):
    def __init__(self):
        pygame.init()
        pygame.mixer.init()
        pygame.mixer.music.load("Pacman_NgThienBao/BTS_FAKELOVE.mp3")
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3") 
        #pygame.mixer.music.set_volume(1.0)
        pygame.mixer.music.play(-1)
        self.screen = pygame.display.set_mode(SCREENSIZE, 0, 32)
        self.background = None
        self.background_norm = None
        self.background_flash = None
        self.clock = pygame.time.Clock()
        self.fruit = None
        self.pause = Pause(True)
        self.level = 0
        self.lives = 10
        self.score = 0
        self.textgroup = TextGroup()
        self.lifesprites = LifeSprites(self.lives)
        self.flashBG = False
        self.flashTime = 0.2
        self.flashTimer = 0
        self.fruitCaptured = []
        self.fruitNode = None
        self.mazedata = MazeData()
        
    
        

    def setBackground(self):
        self.background_norm = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_norm.fill(OPTIONAL)
        self.background_flash = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_flash.fill(BLACK)
        self.background_norm = self.mazesprites.constructBackground(self.background_norm, self.level%5)
        self.background_flash = self.mazesprites.constructBackground(self.background_flash, 5)
        self.flashBG = False
        self.background = self.background_norm
    
    
    def startScreen(self):
        self.running = True
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        return

            self.screen.fill((0, 250, 255))
            font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 30)
            # text = font.render("Press Space to Start", 1, (255, 255, 255))
            # textpos = text.get_rect(centerx=self.screen.get_width()/2)
            # self.screen.blit(text, textpos)
            
            instructions = ["ĐỒ ÁN CUỐI KỲ","Nguyễn Thiên Bảo","Giữ nút mũi tên muốn di chuyển","Nhấn Space để chơi và dừng"]
            for i, instruction in enumerate(instructions):
                instruction_text = font.render(instruction, 1, (255, 20, 100))
                instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/5 + 60 * (i+1))
                self.screen.blit(instruction_text, instruction_pos)
            
            pygame.display.flip()
            
        self.startGame()
    


    def startGame(self):  
            
        self.mazedata.loadMaze(self.level)
        self.mazesprites = MazeSprites(self.mazedata.obj.name+".txt", self.mazedata.obj.name+"_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.mazedata.obj.setPortalPairs(self.nodes)
        self.mazedata.obj.connectHomeNodes(self.nodes)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(*self.mazedata.obj.pacmanStart))
        self.pellets = PelletGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)

        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(0, 3)))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(4, 3)))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 0)))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.mazedata.obj.denyGhostsAccess(self.ghosts, self.nodes)

    def startGame_old(self):      
        self.mazedata.loadMaze(self.level)#######
        self.mazesprites = MazeSprites("maze1.txt", "maze1_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("maze1.txt")
        self.nodes.setPortalPair((0,17), (27,17))
        homekey = self.nodes.createHomeNodes(11.5, 14)
        self.nodes.connectHomeNodes(homekey, (12,14), LEFT)
        self.nodes.connectHomeNodes(homekey, (15,14), RIGHT)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(15, 26))
        self.pellets = PelletGroup("maze1.txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 0+14))
        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(0+11.5, 3+14))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(4+11.5, 3+14))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, LEFT, self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, RIGHT, self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.nodes.denyAccessList(12, 14, UP, self.ghosts)
        self.nodes.denyAccessList(15, 14, UP, self.ghosts)
        self.nodes.denyAccessList(12, 26, UP, self.ghosts)
        self.nodes.denyAccessList(15, 26, UP, self.ghosts)

        

    def update(self):
        dt = self.clock.tick(30) / 800.0
        self.textgroup.update(dt)
        self.pellets.update(dt)
        if not self.pause.paused:
            self.ghosts.update(dt)      
            if self.fruit is not None:
                self.fruit.update(dt)
            self.checkPelletEvents()
            self.checkGhostEvents()
            self.checkFruitEvents()

        if self.pacman.alive:
            if not self.pause.paused:
                self.pacman.update(dt)
        else:
            self.pacman.update(dt)

        if self.flashBG:
            self.flashTimer += dt
            if self.flashTimer >= self.flashTime:
                self.flashTimer = 0
                if self.background == self.background_norm:
                    self.background = self.background_flash
                else:
                    self.background = self.background_norm

        afterPauseMethod = self.pause.update(dt)
        if afterPauseMethod is not None:
            afterPauseMethod()
        self.checkEvents()
        self.render()

    def checkEvents(self):
        for event in pygame.event.get():
            if event.type == QUIT:
                exit()
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    if self.pacman.alive:
                        self.pause.setPause(playerPaused=True)
                        if not self.pause.paused:
                            self.textgroup.hideText()
                            self.showEntities()
                        else:
                            self.textgroup.showText(PAUSETXT)
                            #self.hideEntities()

    def checkPelletEvents(self):
        pellet = self.pacman.eatPellets(self.pellets.pelletList)
        if pellet:
            self.pellets.numEaten += 1
            self.updateScore(pellet.points)
            if self.pellets.numEaten == 30:
                self.ghosts.inky.startNode.allowAccess(RIGHT, self.ghosts.inky)
            if self.pellets.numEaten == 70:
                self.ghosts.clyde.startNode.allowAccess(LEFT, self.ghosts.clyde)
            self.pellets.pelletList.remove(pellet)
            if pellet.name == POWERPELLET:
                self.ghosts.startFreight()
            if self.pellets.isEmpty():
                self.flashBG = True
                self.hideEntities()
                self.pause.setPause(pauseTime=3, func=self.nextLevel)

    def checkGhostEvents(self):
        for ghost in self.ghosts:
            if self.pacman.collideGhost(ghost):
                if ghost.mode.current is FREIGHT:
                    self.pacman.visible = False
                    ghost.visible = False
                    self.updateScore(ghost.points)                  
                    self.textgroup.addText(str(ghost.points), WHITE, ghost.position.x, ghost.position.y, 8, time=1)
                    self.ghosts.updatePoints()
                    self.pause.setPause(pauseTime=1, func=self.showEntities)
                    ghost.startSpawn()
                    self.nodes.allowHomeAccess(ghost)
                elif ghost.mode.current is not SPAWN:
                    if self.pacman.alive:
                        self.lives -=  1
                        self.lifesprites.removeImage()
                        self.pacman.die()               
                        self.ghosts.hide()
                        if self.lives <= 0:
                            self.textgroup.showText(GAMEOVERTXT)
                            self.pause.setPause(pauseTime=3, func=self.restartGame)
                        else:
                            self.pause.setPause(pauseTime=3, func=self.resetLevel)
    
    def checkFruitEvents(self):
        if self.pellets.numEaten == 50 or self.pellets.numEaten == 140:
            if self.fruit is None:
                self.fruit = Fruit(self.nodes.getNodeFromTiles(9, 20), self.level)
                print(self.fruit)
        if self.fruit is not None:
            if self.pacman.collideCheck(self.fruit):
                self.updateScore(self.fruit.points)
                self.textgroup.addText(str(self.fruit.points), WHITE, self.fruit.position.x, self.fruit.position.y, 8, time=1)
                fruitCaptured = False
                for fruit in self.fruitCaptured:
                    if fruit.get_offset() == self.fruit.image.get_offset():
                        fruitCaptured = True
                        break
                if not fruitCaptured:
                    self.fruitCaptured.append(self.fruit.image)
                self.fruit = None
            elif self.fruit.destroy:
                self.fruit = None

    def showEntities(self):
        self.pacman.visible = True
        self.ghosts.show()

    def hideEntities(self):
        self.pacman.visible = False
        self.ghosts.hide()

    def nextLevel(self):
        self.showEntities()
        self.level += 1
        self.pause.paused = True
        self.startGame()
        self.textgroup.updateLevel(self.level)

    def restartGame(self):
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3")
        pygame.mixer.music.play(1)
        self.lives = 10
        self.level = 0
        self.pause.paused = True
        self.fruit = None
        self.startGame()
        self.score = 0
        self.textgroup.updateScore(self.score)
        self.textgroup.updateLevel(self.level)
        self.textgroup.showText(READYTXT)
        self.lifesprites.resetLives(self.lives)
        self.fruitCaptured = []

    def resetLevel(self):
        self.pause.paused = True
        self.pacman.reset()
        self.ghosts.reset()
        self.fruit = None
        self.textgroup.showText(READYTXT)

    def updateScore(self, points):
        self.score += points
        self.textgroup.updateScore(self.score)

    def render(self):
        self.screen.blit(self.background, (0, 0))
        #self.nodes.render(self.screen)
        self.pellets.render(self.screen)
        if self.fruit is not None:
            self.fruit.render(self.screen)
        self.pacman.render(self.screen)
        self.ghosts.render(self.screen)
        self.textgroup.render(self.screen)

        for i in range(len(self.lifesprites.images)):
            x = self.lifesprites.images[i].get_width() * i
            y = SCREENHEIGHT - self.lifesprites.images[i].get_height()
            self.screen.blit(self.lifesprites.images[i], (x, y))

        for i in range(len(self.fruitCaptured)):
            x = SCREENWIDTH - self.fruitCaptured[i].get_width() * (i+1)
            y = SCREENHEIGHT - self.fruitCaptured[i].get_height()
            self.screen.blit(self.fruitCaptured[i], (x, y))

        pygame.display.update()


if __name__ == "__main__":
    game = GameController()
    game.startScreen()
    game.startGame()
    
    while game.running:   
        game.update()
        

//////////////////////
//////////////////////
import pygame
from pygame.locals import *
from constants import *
from pacman import Pacman
from nodes import NodeGroup
from pellets import PelletGroup
from ghosts import GhostGroup
from fruit import Fruit
from pauser import Pause
from text import TextGroup
from sprites import LifeSprites
from sprites import MazeSprites
from mazedata import MazeData

class GameController(object):
    def __init__(self):
        pygame.init()
        pygame.mixer.init()
        #pygame.mixer.music.load("Pacman_NgThienBao/BTS_FAKELOVE.mp3")
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3") 
        #pygame.mixer.music.set_volume(1.0)
        #pygame.mixer.music.play(-1)
        self.screen = pygame.display.set_mode(SCREENSIZE, 0, 32)
        self.background = None
        self.background_norm = None
        self.background_flash = None
        self.clock = pygame.time.Clock()
        self.fruit = None
        self.pause = Pause(True)
        self.level = 0
        self.lives = 1
        self.score = 0
        self.textgroup = TextGroup()
        self.lifesprites = LifeSprites(self.lives)
        self.flashBG = False
        self.flashTime = 0.2
        self.flashTimer = 0
        self.fruitCaptured = []
        self.fruitNode = None
        self.mazedata = MazeData()
        self.running = True
    
        

    def setBackground(self):
        self.background_norm = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_norm.fill(OPTIONAL)
        self.background_flash = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_flash.fill(BLACK)
        self.background_norm = self.mazesprites.constructBackground(self.background_norm, self.level%5)
        self.background_flash = self.mazesprites.constructBackground(self.background_flash, 5)
        self.flashBG = False
        self.background = self.background_norm
        
    
    def startScreen(self):
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        return

            self.screen.fill((0, 250, 255))
            font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 28)
            # text = font.render("Press Space to Start", 1, (255, 255, 255))
            # textpos = text.get_rect(centerx=self.screen.get_width()/2)
            # self.screen.blit(text, textpos)
            
            instructions = ["ĐỒ ÁN CUỐI KỲ","Nguyễn Thiên Bảo","Giữ nút mũi tên để di chuyển","Nhấn Space để chơi và dừng"]
            for i, instruction in enumerate(instructions):
                instruction_text = font.render(instruction, 1, (255, 20, 100))
                instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/5 + 60 * (i+1))
                self.screen.blit(instruction_text, instruction_pos)
            
            pygame.display.flip()
            
    def startScreen2(self):
        
        self.music_options = [ "Pacman_NgThienBao/BTS_FAKELOVE.mp3" ,"Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3" ]
        self.music_option_names = ["[Fake Love Orchestral]","[Buông Đôi Tay Nhau Ra]" ]
        self.music_option_texts = []
        font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 20)

        instructions = ["Click chuột để chọn nhạc, có thể không chọn", "Nhấn Space để chơi"]
        for i, instruction in enumerate(instructions):
            instruction_text = font.render(instruction, 1, (RED))
            instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * i)
            self.music_option_texts.append((instruction_text, instruction_pos))

        for i, music_option_name in enumerate(self.music_option_names):
            music_option_text = font.render(music_option_name, 1, (255, 20, 100))
            music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (i+ len(instructions)))
            self.music_option_texts.append((music_option_text, music_option_pos))

        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        return
                if event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = pygame.mouse.get_pos()
                    for i, (music_option_text, music_option_pos) in enumerate(self.music_option_texts[2:]):
                        if music_option_pos.collidepoint(x, y):
                            pygame.mixer.music.load(self.music_options[i])
                            pygame.mixer.music.play(-1)

            self.screen.fill((0, 250, 255))

            for music_option_text, music_option_pos in self.music_option_texts:
                self.screen.blit(music_option_text, music_option_pos)

            pygame.display.flip()
    


    def startGame(self):  
            
        self.mazedata.loadMaze(self.level)
        self.mazesprites = MazeSprites(self.mazedata.obj.name+".txt", self.mazedata.obj.name+"_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.mazedata.obj.setPortalPairs(self.nodes)
        self.mazedata.obj.connectHomeNodes(self.nodes)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(*self.mazedata.obj.pacmanStart))
        self.pellets = PelletGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)

        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(0, 3)))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(4, 3)))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 0)))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.mazedata.obj.denyGhostsAccess(self.ghosts, self.nodes)

    def startGame_old(self):      
        self.mazedata.loadMaze(self.level)#######
        self.mazesprites = MazeSprites("maze1.txt", "maze1_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("maze1.txt")
        self.nodes.setPortalPair((0,17), (27,17))
        homekey = self.nodes.createHomeNodes(11.5, 14)
        self.nodes.connectHomeNodes(homekey, (12,14), LEFT)
        self.nodes.connectHomeNodes(homekey, (15,14), RIGHT)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(15, 26))
        self.pellets = PelletGroup("maze1.txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 0+14))
        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(0+11.5, 3+14))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(4+11.5, 3+14))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, LEFT, self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, RIGHT, self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.nodes.denyAccessList(12, 14, UP, self.ghosts)
        self.nodes.denyAccessList(15, 14, UP, self.ghosts)
        self.nodes.denyAccessList(12, 26, UP, self.ghosts)
        self.nodes.denyAccessList(15, 26, UP, self.ghosts)

        

    def update(self):
        dt = self.clock.tick(30) / 800.0
        self.textgroup.update(dt)
        self.pellets.update(dt)
        if not self.pause.paused:
            self.ghosts.update(dt)      
            if self.fruit is not None:
                self.fruit.update(dt)
            self.checkPelletEvents()
            self.checkGhostEvents()
            self.checkFruitEvents()

        if self.pacman.alive:
            if not self.pause.paused:
                self.pacman.update(dt)
        else:
            self.pacman.update(dt)

        if self.flashBG:
            self.flashTimer += dt
            if self.flashTimer >= self.flashTime:
                self.flashTimer = 0
                if self.background == self.background_norm:
                    self.background = self.background_flash
                else:
                    self.background = self.background_norm

        afterPauseMethod = self.pause.update(dt)
        if afterPauseMethod is not None:
            afterPauseMethod()
        self.checkEvents()
        self.render()

    def checkEvents(self):
        for event in pygame.event.get():
            if event.type == QUIT:
                exit()
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    if self.pacman.alive:
                        self.pause.setPause(playerPaused=True)
                        if not self.pause.paused:
                            self.textgroup.hideText()
                            self.showEntities()
                        else:
                            self.textgroup.showText(PAUSETXT)
                            #self.hideEntities()

    def checkPelletEvents(self):
        pellet = self.pacman.eatPellets(self.pellets.pelletList)
        if pellet:
            self.pellets.numEaten += 1
            self.updateScore(pellet.points)
            if self.pellets.numEaten == 30:
                self.ghosts.inky.startNode.allowAccess(RIGHT, self.ghosts.inky)
            if self.pellets.numEaten == 70:
                self.ghosts.clyde.startNode.allowAccess(LEFT, self.ghosts.clyde)
            self.pellets.pelletList.remove(pellet)
            if pellet.name == POWERPELLET:
                self.ghosts.startFreight()
            if self.pellets.isEmpty():
                self.flashBG = True
                self.hideEntities()
                self.pause.setPause(pauseTime=3, func=self.nextLevel)

    def checkGhostEvents(self):
        for ghost in self.ghosts:
            if self.pacman.collideGhost(ghost):
                if ghost.mode.current is FREIGHT:
                    self.pacman.visible = False
                    ghost.visible = False
                    self.updateScore(ghost.points)                  
                    self.textgroup.addText(str(ghost.points), WHITE, ghost.position.x, ghost.position.y, 8, time=1)
                    self.ghosts.updatePoints()
                    self.pause.setPause(pauseTime=1, func=self.showEntities)
                    ghost.startSpawn()
                    self.nodes.allowHomeAccess(ghost)
                elif ghost.mode.current is not SPAWN:
                    if self.pacman.alive:
                        self.lives -=  1
                        self.lifesprites.removeImage()
                        self.pacman.die()               
                        self.ghosts.hide()
                        if self.lives <= 0:
                            self.textgroup.showText(GAMEOVERTXT)
                            self.pause.setPause(pauseTime=3, func=self.restartGame)
                        else:
                            self.pause.setPause(pauseTime=3, func=self.resetLevel)
    
    def checkFruitEvents(self):
        if self.pellets.numEaten == 50 or self.pellets.numEaten == 140:
            if self.fruit is None:
                self.fruit = Fruit(self.nodes.getNodeFromTiles(9, 20), self.level)
                print(self.fruit)
        if self.fruit is not None:
            if self.pacman.collideCheck(self.fruit):
                self.updateScore(self.fruit.points)
                self.textgroup.addText(str(self.fruit.points), WHITE, self.fruit.position.x, self.fruit.position.y, 8, time=1)
                fruitCaptured = False
                for fruit in self.fruitCaptured:
                    if fruit.get_offset() == self.fruit.image.get_offset():
                        fruitCaptured = True
                        break
                if not fruitCaptured:
                    self.fruitCaptured.append(self.fruit.image)
                self.fruit = None
            elif self.fruit.destroy:
                self.fruit = None

    def showEntities(self):
        self.pacman.visible = True
        self.ghosts.show()

    def hideEntities(self):
        self.pacman.visible = False
        self.ghosts.hide()

    def nextLevel(self):
        self.showEntities()
        self.level += 1
        self.pause.paused = True
        self.startGame()
        self.textgroup.updateLevel(self.level)

    def restartGame(self):
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3")
        pygame.mixer.music.play(1)
        self.lives = 1
        self.level = 0
        self.pause.paused = True
        self.fruit = None
        self.startGame()
        self.score = 0
        self.textgroup.updateScore(self.score)
        self.textgroup.updateLevel(self.level)
        self.textgroup.showText(READYTXT)
        self.lifesprites.resetLives(self.lives)
        self.fruitCaptured = []

    def resetLevel(self):
        self.pause.paused = True
        self.pacman.reset()
        self.ghosts.reset()
        self.fruit = None
        self.textgroup.showText(READYTXT)

    def updateScore(self, points):
        self.score += points
        self.textgroup.updateScore(self.score)

    def render(self):
        self.screen.blit(self.background, (0, 0))
        #self.nodes.render(self.screen)
        self.pellets.render(self.screen)
        if self.fruit is not None:
            self.fruit.render(self.screen)
        self.pacman.render(self.screen)
        self.ghosts.render(self.screen)
        self.textgroup.render(self.screen)

        for i in range(len(self.lifesprites.images)):
            x = self.lifesprites.images[i].get_width() * i
            y = SCREENHEIGHT - self.lifesprites.images[i].get_height()
            self.screen.blit(self.lifesprites.images[i], (x, y))

        for i in range(len(self.fruitCaptured)):
            x = SCREENWIDTH - self.fruitCaptured[i].get_width() * (i+1)
            y = SCREENHEIGHT - self.fruitCaptured[i].get_height()
            self.screen.blit(self.fruitCaptured[i], (x, y))

        pygame.display.update()


if __name__ == "__main__":
    game = GameController()
    game.startScreen()
    game.startScreen2()
    game.startGame()
    
    while game.running:   
        game.update()

////////////////////////////////////
//////////////////////////////////
///////////////////////////////////
/////////////////////////////////////
import pygame
from pygame.locals import *
from constants import *
from pacman import Pacman
from nodes import NodeGroup
from pellets import PelletGroup
from ghosts import GhostGroup
from fruit import Fruit
from pauser import Pause
from text import TextGroup
from sprites import LifeSprites
from sprites import MazeSprites
from mazedata import MazeData

class GameController(object):
    def __init__(self):
        pygame.init()
        pygame.mixer.init()
        #pygame.mixer.music.load("Pacman_NgThienBao/BTS_FAKELOVE.mp3")
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3") 
        #pygame.mixer.music.set_volume(1.0)
        #pygame.mixer.music.play(-1)
        self.screen = pygame.display.set_mode(SCREENSIZE, 0, 32)
        self.background = None
        self.background_norm = None
        self.background_flash = None
        self.clock = pygame.time.Clock()
        self.fruit = None
        self.pause = Pause(True)
        self.level = 0
        self.lives = 2
        self.score = 0
        self.textgroup = TextGroup()
        self.lifesprites = LifeSprites(self.lives)
        self.flashBG = False
        self.flashTime = 0.2
        self.flashTimer = 0
        self.fruitCaptured = []
        self.fruitNode = None
        self.mazedata = MazeData()
        self.running = True
    
        

    def setBackground(self):
        self.background_norm = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_norm.fill(OPTIONAL)
        self.background_flash = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_flash.fill(BLACK)
        self.background_norm = self.mazesprites.constructBackground(self.background_norm, self.level%5)
        self.background_flash = self.mazesprites.constructBackground(self.background_flash, 5)
        self.flashBG = False
        self.background = self.background_norm
        
    
    def startScreen(self):
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        return

            self.screen.fill((0, 250, 255))
            font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 28)
            # text = font.render("Press Space to Start", 1, (255, 255, 255))
            # textpos = text.get_rect(centerx=self.screen.get_width()/2)
            # self.screen.blit(text, textpos)
            
            instructions = ["ĐỒ ÁN CUỐI KỲ","Nguyễn Thiên Bảo","Giữ nút mũi tên để di chuyển","Nhấn Space để chơi và dừng"]
            for i, instruction in enumerate(instructions):
                instruction_text = font.render(instruction, 1, (255, 20, 100))
                instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/5 + 60 * (i+1))
                self.screen.blit(instruction_text, instruction_pos)
            
            pygame.display.flip()
            
    def startScreen2(self):
        
        self.music_options = [ "Pacman_NgThienBao/BTS_FAKELOVE.mp3",
                               "Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3",
                               "Pacman_NgThienBao/WAKUWAKU.mp3"]
        self.music_option_names = ["[Fake Love Orchestral]",
                                   "[Buông Đôi Tay Nhau Ra]" ,
                                   "[Waku Waku]"]
        self.music_option_texts = []
        font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 20)

        instructions = ["Click chuột để chọn nhạc, có thể không chọn", "Nhấn Space để chơi và dừng"]
        for i, instruction in enumerate(instructions):
            instruction_text = font.render(instruction, 1, (255, 255, 255))
            instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * i)
            self.music_option_texts.append((instruction_text, instruction_pos))

        for i, music_option_name in enumerate(self.music_option_names):
            music_option_text = font.render(music_option_name, 1, (0, 255, 255))
            music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (i+ len(instructions)))
            self.music_option_texts.append((music_option_text, music_option_pos))

        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False

                if event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = pygame.mouse.get_pos()
                    for i, (music_option_text, music_option_pos) in enumerate(self.music_option_texts[2:]):
                        if music_option_pos.collidepoint(x, y):
                            pygame.mixer.music.load(self.music_options[i])
                            pygame.mixer.music.play(-1)
                        
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        if not pygame.mixer.music.get_busy():  # Kiểm tra xem có nhạc đang chạy không
                            pygame.mixer.music.load(self.music_options[0])  # Ko chọn thì mặc định chạy nhạc 0
                            pygame.mixer.music.play(-1)
                        return   

            self.screen.fill((OPTIONAL))

            for music_option_text, music_option_pos in self.music_option_texts:
                self.screen.blit(music_option_text, music_option_pos)

            pygame.display.flip()
    


    def startGame(self):  
            
        self.mazedata.loadMaze(self.level)
        self.mazesprites = MazeSprites(self.mazedata.obj.name+".txt", self.mazedata.obj.name+"_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.mazedata.obj.setPortalPairs(self.nodes)
        self.mazedata.obj.connectHomeNodes(self.nodes)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(*self.mazedata.obj.pacmanStart))
        self.pellets = PelletGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)

        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(0, 3)))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(4, 3)))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 0)))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.mazedata.obj.denyGhostsAccess(self.ghosts, self.nodes)

    def startGame_old(self):      
        self.mazedata.loadMaze(self.level)#######
        self.mazesprites = MazeSprites("maze1.txt", "maze1_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("maze1.txt")
        self.nodes.setPortalPair((0,17), (27,17))
        homekey = self.nodes.createHomeNodes(11.5, 14)
        self.nodes.connectHomeNodes(homekey, (12,14), LEFT)
        self.nodes.connectHomeNodes(homekey, (15,14), RIGHT)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(15, 26))
        self.pellets = PelletGroup("maze1.txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 0+14))
        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(0+11.5, 3+14))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(4+11.5, 3+14))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, LEFT, self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, RIGHT, self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.nodes.denyAccessList(12, 14, UP, self.ghosts)
        self.nodes.denyAccessList(15, 14, UP, self.ghosts)
        self.nodes.denyAccessList(12, 26, UP, self.ghosts)
        self.nodes.denyAccessList(15, 26, UP, self.ghosts)

        

    def update(self):
        dt = self.clock.tick(30) / 800.0
        self.textgroup.update(dt)
        self.pellets.update(dt)
        if not self.pause.paused:
            self.ghosts.update(dt)      
            if self.fruit is not None:
                self.fruit.update(dt)
            self.checkPelletEvents()
            self.checkGhostEvents()
            self.checkFruitEvents()

        if self.pacman.alive:
            if not self.pause.paused:
                self.pacman.update(dt)
        else:
            self.pacman.update(dt)

        if self.flashBG:
            self.flashTimer += dt
            if self.flashTimer >= self.flashTime:
                self.flashTimer = 0
                if self.background == self.background_norm:
                    self.background = self.background_flash
                else:
                    self.background = self.background_norm

        afterPauseMethod = self.pause.update(dt)
        if afterPauseMethod is not None:
            afterPauseMethod()
        self.checkEvents()
        self.render()

    def checkEvents(self):
        for event in pygame.event.get():
            if event.type == QUIT:
                exit()
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    if self.pacman.alive:
                        self.pause.setPause(playerPaused=True)
                        if not self.pause.paused:
                            self.textgroup.hideText()
                            self.showEntities()
                        else:
                            self.textgroup.showText(PAUSETXT)
                            #self.hideEntities()

    def checkPelletEvents(self):
        pellet = self.pacman.eatPellets(self.pellets.pelletList)
        if pellet:
            self.pellets.numEaten += 1
            self.updateScore(pellet.points)
            if self.pellets.numEaten == 30:
                self.ghosts.inky.startNode.allowAccess(RIGHT, self.ghosts.inky)
            if self.pellets.numEaten == 70:
                self.ghosts.clyde.startNode.allowAccess(LEFT, self.ghosts.clyde)
            self.pellets.pelletList.remove(pellet)
            if pellet.name == POWERPELLET:
                self.ghosts.startFreight()
            if self.pellets.isEmpty():
                self.flashBG = True
                self.hideEntities()
                self.pause.setPause(pauseTime=3, func=self.nextLevel)

    def checkGhostEvents(self):
        for ghost in self.ghosts:
            if self.pacman.collideGhost(ghost):
                if ghost.mode.current is FREIGHT:
                    self.pacman.visible = False
                    ghost.visible = False
                    self.updateScore(ghost.points)                  
                    self.textgroup.addText(str(ghost.points), WHITE, ghost.position.x, ghost.position.y, 8, time=1)
                    self.ghosts.updatePoints()
                    self.pause.setPause(pauseTime=1, func=self.showEntities)
                    ghost.startSpawn()
                    self.nodes.allowHomeAccess(ghost)
                elif ghost.mode.current is not SPAWN:
                    if self.pacman.alive:
                        self.lives -=  1
                        self.lifesprites.removeImage()
                        self.pacman.die()               
                        self.ghosts.hide()
                        if self.lives <= 0:
                            self.textgroup.showText(GAMEOVERTXT)
                            self.pause.setPause(pauseTime=3, func=self.restartGame)
                        else:
                            self.pause.setPause(pauseTime=3, func=self.resetLevel)
    
    def checkFruitEvents(self):
        if self.pellets.numEaten == 50 or self.pellets.numEaten == 140:
            if self.fruit is None:
                self.fruit = Fruit(self.nodes.getNodeFromTiles(9, 20), self.level)
                print(self.fruit)
        if self.fruit is not None:
            if self.pacman.collideCheck(self.fruit):
                self.updateScore(self.fruit.points)
                self.textgroup.addText(str(self.fruit.points), WHITE, self.fruit.position.x, self.fruit.position.y, 8, time=1)
                fruitCaptured = False
                for fruit in self.fruitCaptured:
                    if fruit.get_offset() == self.fruit.image.get_offset():
                        fruitCaptured = True
                        break
                if not fruitCaptured:
                    self.fruitCaptured.append(self.fruit.image)
                self.fruit = None
            elif self.fruit.destroy:
                self.fruit = None

    def showEntities(self):
        self.pacman.visible = True
        self.ghosts.show()

    def hideEntities(self):
        self.pacman.visible = False
        self.ghosts.hide()

    def nextLevel(self):
        self.showEntities()
        self.level += 1
        self.pause.paused = True
        self.startGame()
        self.textgroup.updateLevel(self.level)

    def restartGame(self):
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3")
        pygame.mixer.music.play(1)
        self.lives = 1
        self.level = 0
        self.pause.paused = True
        self.fruit = None
        self.startGame()
        self.score = 0
        self.textgroup.updateScore(self.score)
        self.textgroup.updateLevel(self.level)
        self.textgroup.showText(READYTXT)
        self.lifesprites.resetLives(self.lives)
        self.fruitCaptured = []

    def resetLevel(self):
        self.pause.paused = True
        self.pacman.reset()
        self.ghosts.reset()
        self.fruit = None
        self.textgroup.showText(READYTXT)

    def updateScore(self, points):
        self.score += points
        self.textgroup.updateScore(self.score)

    def render(self):
        self.screen.blit(self.background, (0, 0))
        #self.nodes.render(self.screen)
        self.pellets.render(self.screen)
        if self.fruit is not None:
            self.fruit.render(self.screen)
        self.pacman.render(self.screen)
        self.ghosts.render(self.screen)
        self.textgroup.render(self.screen)

        for i in range(len(self.lifesprites.images)):
            x = self.lifesprites.images[i].get_width() * i
            y = SCREENHEIGHT - self.lifesprites.images[i].get_height()
            self.screen.blit(self.lifesprites.images[i], (x, y))

        for i in range(len(self.fruitCaptured)):
            x = SCREENWIDTH - self.fruitCaptured[i].get_width() * (i+1)
            y = SCREENHEIGHT - self.fruitCaptured[i].get_height()
            self.screen.blit(self.fruitCaptured[i], (x, y))

        pygame.display.update()


if __name__ == "__main__":
    game = GameController()
    game.startScreen()
    game.startScreen2()
    game.startGame()
    
    while game.running:   
        game.update()

/////////////////////////////////////////
///////////////////////////////////////
//////////////////////////////////////
import pygame
from pygame.locals import *
from constants import *
from pacman import Pacman
from nodes import NodeGroup
from pellets import PelletGroup
from ghosts import GhostGroup
from fruit import Fruit
from pauser import Pause
from text import TextGroup
from sprites import LifeSprites
from sprites import MazeSprites
from mazedata import MazeData

class GameController(object):
    def __init__(self):
        pygame.init()
        pygame.mixer.init()
        #pygame.mixer.music.load("Pacman_NgThienBao/BTS_FAKELOVE.mp3")
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3") 
        #pygame.mixer.music.set_volume(1.0)
        #pygame.mixer.music.play(-1)
        self.screen = pygame.display.set_mode(SCREENSIZE, 0, 32)
        self.background = None
        self.background_norm = None
        self.background_flash = None
        self.clock = pygame.time.Clock()
        self.fruit = None
        self.pause = Pause(True)
        self.level = 0
        self.lives = 2
        self.score = 0
        self.textgroup = TextGroup()
        self.lifesprites = LifeSprites(self.lives)
        self.flashBG = False
        self.flashTime = 0.2
        self.flashTimer = 0
        self.fruitCaptured = []
        self.fruitNode = None
        self.mazedata = MazeData()
        self.running = True
    
        

    def setBackground(self):
        self.background_norm = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_norm.fill(OPTIONAL)
        self.background_flash = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_flash.fill(BLACK)
        self.background_norm = self.mazesprites.constructBackground(self.background_norm, self.level%5)
        self.background_flash = self.mazesprites.constructBackground(self.background_flash, 5)
        self.flashBG = False
        self.background = self.background_norm
        
    
    def startScreen(self):
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        return

            self.screen.fill((0, 250, 255))
            font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 28)
            # text = font.render("Press Space to Start", 1, (255, 255, 255))
            # textpos = text.get_rect(centerx=self.screen.get_width()/2)
            # self.screen.blit(text, textpos)
            
            instructions = ["ĐỒ ÁN CUỐI KỲ","Nguyễn Thiên Bảo","Giữ nút mũi tên để di chuyển","Nhấn Space để chơi và dừng"]
            for i, instruction in enumerate(instructions):
                instruction_text = font.render(instruction, 1, (255, 20, 100))
                instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/5 + 60 * (i+1))
                self.screen.blit(instruction_text, instruction_pos)
            
            pygame.display.flip()
            
    def startScreen2(self):
        
        self.music_options = [ "Pacman_NgThienBao/BTS_FAKELOVE.mp3",
                               "Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3",
                               "Pacman_NgThienBao/CAUSEILOVEYOU.mp3",
                               "Pacman_NgThienBao/HARUHARU.mp3",
                               "Pacman_NgThienBao/WAKUWAKU.mp3"]
        self.music_option_names = ["[Fake Love Orchestral]",
                                   "[Buông Đôi Tay Nhau Ra]",
                                   "[Cause I Love You]",
                                   "[BigBang-Haru Haru]",
                                   "[Waku Waku]"]
        self.music_option_texts = []
        font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 20)

        instructions = ["Click chuột để chọn nhạc, có thể không chọn", "Nhấn Space để chơi và tạm dừng"]
        for i, instruction in enumerate(instructions):
            instruction_text = font.render(instruction, 1, (255, 255, 255))
            instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * i)
            self.music_option_texts.append((instruction_text, instruction_pos))

        for i, music_option_name in enumerate(self.music_option_names):
            music_option_text = font.render(music_option_name, 1, (0, 255, 255))
            music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (i+ len(instructions)))
            self.music_option_texts.append((music_option_text, music_option_pos))
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False

                if event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = pygame.mouse.get_pos()
                    for i, (music_option_text, music_option_pos) in enumerate(self.music_option_texts[2:]):
                        if music_option_pos.collidepoint(x, y):
                            pygame.mixer.music.load(self.music_options[i])
                            pygame.mixer.music.play(-1)
                        
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        if not pygame.mixer.music.get_busy():  # Kiểm tra xem có nhạc đang chạy không
                            pygame.mixer.music.load(self.music_options[0])  # Ko chọn thì mặc định chạy nhạc 0
                            pygame.mixer.music.play(-1)
                        return   

            self.screen.fill((OPTIONAL))

            for music_option_text, music_option_pos in self.music_option_texts:
                self.screen.blit(music_option_text, music_option_pos)

            pygame.display.flip()
    


    def startGame(self):  
            
        self.mazedata.loadMaze(self.level)
        self.mazesprites = MazeSprites(self.mazedata.obj.name+".txt", self.mazedata.obj.name+"_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.mazedata.obj.setPortalPairs(self.nodes)
        self.mazedata.obj.connectHomeNodes(self.nodes)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(*self.mazedata.obj.pacmanStart))
        self.pellets = PelletGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)

        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(0, 3)))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(4, 3)))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 0)))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.mazedata.obj.denyGhostsAccess(self.ghosts, self.nodes)

    def startGame_old(self):      
        self.mazedata.loadMaze(self.level)#######
        self.mazesprites = MazeSprites("maze1.txt", "maze1_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("maze1.txt")
        self.nodes.setPortalPair((0,17), (27,17))
        homekey = self.nodes.createHomeNodes(11.5, 14)
        self.nodes.connectHomeNodes(homekey, (12,14), LEFT)
        self.nodes.connectHomeNodes(homekey, (15,14), RIGHT)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(15, 26))
        self.pellets = PelletGroup("maze1.txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 0+14))
        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(0+11.5, 3+14))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(4+11.5, 3+14))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, LEFT, self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, RIGHT, self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.nodes.denyAccessList(12, 14, UP, self.ghosts)
        self.nodes.denyAccessList(15, 14, UP, self.ghosts)
        self.nodes.denyAccessList(12, 26, UP, self.ghosts)
        self.nodes.denyAccessList(15, 26, UP, self.ghosts)

        

    def update(self):
        dt = self.clock.tick(30) / 800.0
        self.textgroup.update(dt)
        self.pellets.update(dt)
        if not self.pause.paused:
            self.ghosts.update(dt)      
            if self.fruit is not None:
                self.fruit.update(dt)
            self.checkPelletEvents()
            self.checkGhostEvents()
            self.checkFruitEvents()

        if self.pacman.alive:
            if not self.pause.paused:
                self.pacman.update(dt)
        else:
            self.pacman.update(dt)

        if self.flashBG:
            self.flashTimer += dt
            if self.flashTimer >= self.flashTime:
                self.flashTimer = 0
                if self.background == self.background_norm:
                    self.background = self.background_flash
                else:
                    self.background = self.background_norm

        afterPauseMethod = self.pause.update(dt)
        if afterPauseMethod is not None:
            afterPauseMethod()
        self.checkEvents()
        self.render()

    def checkEvents(self):
        for event in pygame.event.get():
            if event.type == QUIT:
                exit()
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    if self.pacman.alive:
                        self.pause.setPause(playerPaused=True)
                        if not self.pause.paused:
                            self.textgroup.hideText()
                            self.showEntities()
                        else:
                            self.textgroup.showText(PAUSETXT)
                            #self.hideEntities()

    def checkPelletEvents(self):
        pellet = self.pacman.eatPellets(self.pellets.pelletList)
        if pellet:
            self.pellets.numEaten += 1
            self.updateScore(pellet.points)
            if self.pellets.numEaten == 30:
                self.ghosts.inky.startNode.allowAccess(RIGHT, self.ghosts.inky)
            if self.pellets.numEaten == 70:
                self.ghosts.clyde.startNode.allowAccess(LEFT, self.ghosts.clyde)
            self.pellets.pelletList.remove(pellet)
            if pellet.name == POWERPELLET:
                self.ghosts.startFreight()
            if self.pellets.isEmpty():
                self.flashBG = True
                self.hideEntities()
                self.pause.setPause(pauseTime=3, func=self.nextLevel)

    def checkGhostEvents(self):
        for ghost in self.ghosts:
            if self.pacman.collideGhost(ghost):
                if ghost.mode.current is FREIGHT:
                    self.pacman.visible = False
                    ghost.visible = False
                    self.updateScore(ghost.points)                  
                    self.textgroup.addText(str(ghost.points), WHITE, ghost.position.x, ghost.position.y, 8, time=1)
                    self.ghosts.updatePoints()
                    self.pause.setPause(pauseTime=1, func=self.showEntities)
                    ghost.startSpawn()
                    self.nodes.allowHomeAccess(ghost)
                elif ghost.mode.current is not SPAWN:
                    if self.pacman.alive:
                        self.lives -=  1
                        self.lifesprites.removeImage()
                        self.pacman.die()               
                        self.ghosts.hide()
                        if self.lives <= 0:
                            self.textgroup.showText(GAMEOVERTXT)
                            self.pause.setPause(pauseTime=3, func=self.restartGame)
                        else:
                            self.pause.setPause(pauseTime=3, func=self.resetLevel)
    
    def checkFruitEvents(self):
        if self.pellets.numEaten == 50 or self.pellets.numEaten == 140:
            if self.fruit is None:
                self.fruit = Fruit(self.nodes.getNodeFromTiles(9, 20), self.level)
                print(self.fruit)
        if self.fruit is not None:
            if self.pacman.collideCheck(self.fruit):
                self.updateScore(self.fruit.points)
                self.textgroup.addText(str(self.fruit.points), WHITE, self.fruit.position.x, self.fruit.position.y, 8, time=1)
                fruitCaptured = False
                for fruit in self.fruitCaptured:
                    if fruit.get_offset() == self.fruit.image.get_offset():
                        fruitCaptured = True
                        break
                if not fruitCaptured:
                    self.fruitCaptured.append(self.fruit.image)
                self.fruit = None
            elif self.fruit.destroy:
                self.fruit = None

    def showEntities(self):
        self.pacman.visible = True
        self.ghosts.show()

    def hideEntities(self):
        self.pacman.visible = False
        self.ghosts.hide()

    def nextLevel(self):
        self.showEntities()
        self.level += 1
        self.pause.paused = True
        self.startGame()
        self.textgroup.updateLevel(self.level)

    def restartGame(self):
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3")
        pygame.mixer.music.play(1)
        self.lives = 1
        self.level = 0
        self.pause.paused = True
        self.fruit = None
        self.startGame()
        self.score = 0
        self.textgroup.updateScore(self.score)
        self.textgroup.updateLevel(self.level)
        self.textgroup.showText(READYTXT)
        self.lifesprites.resetLives(self.lives)
        self.fruitCaptured = []

    def resetLevel(self):
        self.pause.paused = True
        self.pacman.reset()
        self.ghosts.reset()
        self.fruit = None
        self.textgroup.showText(READYTXT)

    def updateScore(self, points):
        self.score += points
        self.textgroup.updateScore(self.score)

    def render(self):
        self.screen.blit(self.background, (0, 0))
        #self.nodes.render(self.screen)
        self.pellets.render(self.screen)
        if self.fruit is not None:
            self.fruit.render(self.screen)
        self.pacman.render(self.screen)
        self.ghosts.render(self.screen)
        self.textgroup.render(self.screen)

        for i in range(len(self.lifesprites.images)):
            x = self.lifesprites.images[i].get_width() * i
            y = SCREENHEIGHT - self.lifesprites.images[i].get_height()
            self.screen.blit(self.lifesprites.images[i], (x, y))

        for i in range(len(self.fruitCaptured)):
            x = SCREENWIDTH - self.fruitCaptured[i].get_width() * (i+1)
            y = SCREENHEIGHT - self.fruitCaptured[i].get_height()
            self.screen.blit(self.fruitCaptured[i], (x, y))

        pygame.display.update()


if __name__ == "__main__":
    game = GameController()
    game.startScreen()
    game.startScreen2()
    game.startGame()
    
    while game.running:   
        game.update()
/////////////////////////////////////////

///////////////////////////////////////
//////////////////////////////////////
import pygame
from pygame.locals import *
from constants import *
from sys import *
from pacman import Pacman
from nodes import NodeGroup
from pellets import PelletGroup
from ghosts import GhostGroup
from fruit import Fruit
from pauser import Pause
from text import TextGroup
from sprites import LifeSprites
from sprites import MazeSprites
from mazedata import MazeData

class GameController(object):
    def __init__(self):
        pygame.init()
        pygame.mixer.init()
        #pygame.mixer.music.load("Pacman_NgThienBao/BTS_FAKELOVE.mp3")
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3") 
        #pygame.mixer.music.set_volume(1.0)
        #pygame.mixer.music.play(-1)
        self.screen = pygame.display.set_mode(SCREENSIZE, 0, 32)
        self.background = None
        self.background_norm = None
        self.background_flash = None
        self.clock = pygame.time.Clock()
        self.fruit = None
        self.pause = Pause(True)
        self.level = 0
        self.lives = 2
        self.score = 0
        self.textgroup = TextGroup()
        self.lifesprites = LifeSprites(self.lives)
        self.flashBG = False
        self.flashTime = 0.2
        self.flashTimer = 0
        self.fruitCaptured = []
        self.fruitNode = None
        self.mazedata = MazeData()
        self.running = True
    
        

    def setBackground(self):
        self.background_norm = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_norm.fill(OPTIONAL)
        self.background_flash = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_flash.fill(BLACK)
        self.background_norm = self.mazesprites.constructBackground(self.background_norm, self.level%5)
        self.background_flash = self.mazesprites.constructBackground(self.background_flash, 5)
        self.flashBG = False
        self.background = self.background_norm
        
    
    def startScreen(self):
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        return

            self.screen.fill((0, 250, 255))
            font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 28)
            # text = font.render("Press Space to Start", 1, (255, 255, 255))
            # textpos = text.get_rect(centerx=self.screen.get_width()/2)
            # self.screen.blit(text, textpos)
            
            instructions = ["ĐỒ ÁN CUỐI KỲ DSA","GAME PACMAN","Nguyễn Thiên Bảo","Nhấn Space để tiếp tục"]
            for i, instruction in enumerate(instructions):
                instruction_text = font.render(instruction, 1, (255, 20, 100))
                instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/5 + 60 * (i+1))
                self.screen.blit(instruction_text, instruction_pos)
            
            pygame.display.flip()
            
    def startScreen2(self):
        
        self.music_options = [ "Pacman_NgThienBao/BTS_FAKELOVE.mp3",
                               "Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3",
                               "Pacman_NgThienBao/CAUSEILOVEYOU.mp3",
                               "Pacman_NgThienBao/HARUHARU.mp3",
                               "Pacman_NgThienBao/XICHLINH.mp3",
                               "Pacman_NgThienBao/ATTACKONTITAN1.mp3",
                               "Pacman_NgThienBao/5CMS.mp3"]
        self.music_option_names = ["[Fake Love Orchestral]",
                                   "[Buông Đôi Tay Nhau Ra]",
                                   "[Cause I Love You]",
                                   "[BigBang-Haru Haru]",
                                   "[Xích Linh Remix]",
                                   "[Attack On Titan]",
                                   "[5 Cm/s]"]
        self.music_option_texts = []
        font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 20)

        instructions = ["Click chuột để chọn nhạc, có thể không chọn", "Nhấn Space để chơi và tạm dừng", "Giữ nút mũi tên để di chuyển"]
        for i, instruction in enumerate(instructions):
            instruction_text = font.render(instruction, 1, (255, 255, 255))
            instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * i)
            self.music_option_texts.append((instruction_text, instruction_pos))

        for i, music_option_name in enumerate(self.music_option_names):
            music_option_text = font.render(music_option_name, 1, (0, 255, 255))
            music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (i+ len(instructions)))
            self.music_option_texts.append((music_option_text, music_option_pos))
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False

                if event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = pygame.mouse.get_pos()
                    for i, (music_option_text, music_option_pos) in enumerate(self.music_option_texts[len(instructions):]):
                        if music_option_pos.collidepoint(x, y):
                            pygame.mixer.music.load(self.music_options[i])
                            pygame.mixer.music.play(-1)
                        
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        if not pygame.mixer.music.get_busy():  # Kiểm tra xem có nhạc đang chạy không
                            pygame.mixer.music.load(self.music_options[0])  # Ko chọn thì mặc định chạy nhạc 0
                            pygame.mixer.music.set_volume(0)
                            pygame.mixer.music.play(-1)
                        return   

            self.screen.fill((OPTIONAL))

            for music_option_text, music_option_pos in self.music_option_texts:
                self.screen.blit(music_option_text, music_option_pos)

            pygame.display.flip()
    


    def startGame(self):  
            
        self.mazedata.loadMaze(self.level)
        self.mazesprites = MazeSprites(self.mazedata.obj.name+".txt", self.mazedata.obj.name+"_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.mazedata.obj.setPortalPairs(self.nodes)
        self.mazedata.obj.connectHomeNodes(self.nodes)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(*self.mazedata.obj.pacmanStart))
        self.pellets = PelletGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)

        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(0, 3)))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(4, 3)))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 0)))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.mazedata.obj.denyGhostsAccess(self.ghosts, self.nodes)

    def startGame_old(self):      
        self.mazedata.loadMaze(self.level)#######
        self.mazesprites = MazeSprites("maze1.txt", "maze1_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("maze1.txt")
        self.nodes.setPortalPair((0,17), (27,17))
        homekey = self.nodes.createHomeNodes(11.5, 14)
        self.nodes.connectHomeNodes(homekey, (12,14), LEFT)
        self.nodes.connectHomeNodes(homekey, (15,14), RIGHT)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(15, 26))
        self.pellets = PelletGroup("maze1.txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 0+14))
        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(0+11.5, 3+14))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(4+11.5, 3+14))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, LEFT, self.ghosts)
        self.nodes.denyAccessList(2+11.5, 3+14, RIGHT, self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.nodes.denyAccessList(12, 14, UP, self.ghosts)
        self.nodes.denyAccessList(15, 14, UP, self.ghosts)
        self.nodes.denyAccessList(12, 26, UP, self.ghosts)
        self.nodes.denyAccessList(15, 26, UP, self.ghosts)

        

    def update(self):
        dt = self.clock.tick(30) / 800.0
        self.textgroup.update(dt)
        self.pellets.update(dt)
        if not self.pause.paused:
            self.ghosts.update(dt)      
            if self.fruit is not None:
                self.fruit.update(dt)
            self.checkPelletEvents()
            self.checkGhostEvents()
            self.checkFruitEvents()

        if self.pacman.alive:
            if not self.pause.paused:
                self.pacman.update(dt)
        else:
            self.pacman.update(dt)

        if self.flashBG:
            self.flashTimer += dt
            if self.flashTimer >= self.flashTime:
                self.flashTimer = 0
                if self.background == self.background_norm:
                    self.background = self.background_flash
                else:
                    self.background = self.background_norm

        afterPauseMethod = self.pause.update(dt)
        if afterPauseMethod is not None:
            afterPauseMethod()
        self.checkEvents()
        self.render()

    def checkEvents(self):
        for event in pygame.event.get():
            if event.type == QUIT:
                exit()
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    if self.pacman.alive:
                        self.pause.setPause(playerPaused=True)
                        if not self.pause.paused:
                            self.textgroup.hideText()
                            self.showEntities()
                        else:
                            self.textgroup.showText(PAUSETXT)
                            #self.hideEntities()

    def checkPelletEvents(self):
        pellet = self.pacman.eatPellets(self.pellets.pelletList)
        if pellet:
            self.pellets.numEaten += 1
            self.updateScore(pellet.points)
            if self.pellets.numEaten == 30:
                self.ghosts.inky.startNode.allowAccess(RIGHT, self.ghosts.inky)
            if self.pellets.numEaten == 70:
                self.ghosts.clyde.startNode.allowAccess(LEFT, self.ghosts.clyde)
            self.pellets.pelletList.remove(pellet)
            if pellet.name == POWERPELLET:
                self.ghosts.startFreight()
            if self.pellets.isEmpty():
                self.flashBG = True
                self.hideEntities()
                self.pause.setPause(pauseTime=3, func=self.nextLevel)

    def checkGhostEvents(self):
        for ghost in self.ghosts:
            if self.pacman.collideGhost(ghost):
                if ghost.mode.current is FREIGHT:
                    self.pacman.visible = False
                    ghost.visible = False
                    self.updateScore(ghost.points)                  
                    self.textgroup.addText(str(ghost.points), WHITE, ghost.position.x, ghost.position.y, 8, time=1)
                    self.ghosts.updatePoints()
                    self.pause.setPause(pauseTime=1, func=self.showEntities)
                    ghost.startSpawn()
                    self.nodes.allowHomeAccess(ghost)
                elif ghost.mode.current is not SPAWN:
                    if self.pacman.alive:
                        self.lives -=  1
                        self.lifesprites.removeImage()
                        self.pacman.die()               
                        self.ghosts.hide()
                        if self.lives <= 0:
                            self.textgroup.showText(GAMEOVERTXT)
                            self.pause.setPause(pauseTime=3, func=self.restartGame)
                        else:
                            self.pause.setPause(pauseTime=3, func=self.resetLevel)
    
    def checkFruitEvents(self):
        if self.pellets.numEaten == 50 or self.pellets.numEaten == 140:
            if self.fruit is None:
                self.fruit = Fruit(self.nodes.getNodeFromTiles(9, 20), self.level)
                print(self.fruit)
        if self.fruit is not None:
            if self.pacman.collideCheck(self.fruit):
                self.updateScore(self.fruit.points)
                self.textgroup.addText(str(self.fruit.points), WHITE, self.fruit.position.x, self.fruit.position.y, 8, time=1)
                fruitCaptured = False
                for fruit in self.fruitCaptured:
                    if fruit.get_offset() == self.fruit.image.get_offset():
                        fruitCaptured = True
                        break
                if not fruitCaptured:
                    self.fruitCaptured.append(self.fruit.image)
                self.fruit = None
            elif self.fruit.destroy:
                self.fruit = None

    def showEntities(self):
        self.pacman.visible = True
        self.ghosts.show()

    def hideEntities(self):
        self.pacman.visible = False
        self.ghosts.hide()

    def nextLevel(self):
        self.showEntities()
        self.level += 1
        self.pause.paused = True
        self.startGame()
        self.textgroup.updateLevel(self.level)

    def restartGame(self):
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3")
        pygame.mixer.music.play(1)
        self.lives = 1
        self.level = 0
        self.pause.paused = True
        self.fruit = None
        self.startGame()
        self.score = 0
        self.textgroup.updateScore(self.score)
        self.textgroup.updateLevel(self.level)
        self.textgroup.showText(READYTXT)
        self.lifesprites.resetLives(self.lives)
        self.fruitCaptured = []

    def resetLevel(self):
        self.pause.paused = True
        self.pacman.reset()
        self.ghosts.reset()
        self.fruit = None
        self.textgroup.showText(READYTXT)

    def updateScore(self, points):
        self.score += points
        self.textgroup.updateScore(self.score)

    def render(self):
        self.screen.blit(self.background, (0, 0))
        #self.nodes.render(self.screen)
        self.pellets.render(self.screen)
        if self.fruit is not None:
            self.fruit.render(self.screen)
        self.pacman.render(self.screen)
        self.ghosts.render(self.screen)
        self.textgroup.render(self.screen)

        for i in range(len(self.lifesprites.images)):
            x = self.lifesprites.images[i].get_width() * i
            y = SCREENHEIGHT - self.lifesprites.images[i].get_height()
            self.screen.blit(self.lifesprites.images[i], (x, y))

        for i in range(len(self.fruitCaptured)):
            x = SCREENWIDTH - self.fruitCaptured[i].get_width() * (i+1)
            y = SCREENHEIGHT - self.fruitCaptured[i].get_height()
            self.screen.blit(self.fruitCaptured[i], (x, y))

        pygame.display.update()


if __name__ == "__main__":
    game = GameController()
    game.startScreen()
    game.startScreen2()
    game.startGame()
    
    while game.running:   
        game.update()


/////////////////////////////////////////////////////
////////////////////////////////////////////////////
////////////
///

////////////////////////////////
import pygame
from pygame.locals import *
from constants import *
from sys import *
from pacman import Pacman
from nodes import NodeGroup
from pellets import PelletGroup
from ghosts import GhostGroup
from fruit import Fruit
from pauser import Pause
from text import TextGroup
from sprites import LifeSprites
from sprites import MazeSprites
from mazedata import MazeData

class GameController(object):
    def __init__(self):
        pygame.init()
        pygame.mixer.init()
        #pygame.mixer.music.load("Pacman_NgThienBao/BTS_FAKELOVE.mp3")
        #pygame.mixer.music.set_volume(1.0)
        #pygame.mixer.music.play(-1)
        self.screen = pygame.display.set_mode(SCREENSIZE, 0, 32)
        self.background = None
        self.background_norm = None
        self.background_flash = None
        self.clock = pygame.time.Clock()
        self.fruit = None
        self.pause = Pause(True)
        self.level = 0
        self.lives = 2
        self.score = 0
        self.textgroup = TextGroup()
        self.lifesprites = LifeSprites(self.lives)
        self.flashBG = False
        self.flashTime = 0.2
        self.flashTimer = 0
        self.fruitCaptured = []
        self.fruitNode = None
        self.mazedata = MazeData()
        self.running = True
        
    
        

    def setBackground(self):
        self.background_norm = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_norm.fill(OPTIONAL)
        self.background_flash = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_flash.fill(BLACK)
        self.background_norm = self.mazesprites.constructBackground(self.background_norm, self.level%5)
        self.background_flash = self.mazesprites.constructBackground(self.background_flash, 5)
        self.flashBG = False
        self.background = self.background_norm
        
    
    def startScreen(self):
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        return

            self.screen.fill((0, 250, 255))
            font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 28)
            # text = font.render("Press Space to Start", 1, (255, 255, 255))
            # textpos = text.get_rect(centerx=self.screen.get_width()/2)
            # self.screen.blit(text, textpos)
            
            instructions = ["ĐỒ ÁN CUỐI KỲ DSA","GAME PACMAN","Nguyễn Thiên Bảo","Nhấn Space để tiếp tục"]
            for i, instruction in enumerate(instructions):
                instruction_text = font.render(instruction, 1, (255, 20, 100))
                instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/5 + 60 * (i+1))
                self.screen.blit(instruction_text, instruction_pos)
            
            pygame.display.flip()
            
    def startScreen2(self):
        
        self.music_options = [ "Pacman_NgThienBao/BTS_FAKELOVE.mp3",
                               "Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3",
                               "Pacman_NgThienBao/CAUSEILOVEYOU.mp3",
                               "Pacman_NgThienBao/HARUHARU.mp3",
                               "Pacman_NgThienBao/XICHLINH.mp3",
                               "Pacman_NgThienBao/ATTACKONTITAN1.mp3",
                               "Pacman_NgThienBao/5CMS.mp3"]
        self.music_option_names = ["[Fake Love Orchestral]",
                                   "[Buông Đôi Tay Nhau Ra]",
                                   "[Cause I Love You]",
                                   "[BigBang-Haru Haru]",
                                   "[Xích Linh Remix]",
                                   "[Attack On Titan]",
                                   "[5 Cm/s]"]
        self.music_option_texts = []
        
        font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 20)

        instructions = ["Click chuột để chọn nhạc, có thể không chọn", "Nhấn Space để chơi và tạm dừng", "Giữ nút mũi tên để di chuyển"]
        # Khởi tạo một danh sách để lưu trữ trạng thái của từng lựa chọn nhạc
        self.music_option_states = [False] * len(self.music_option_names)
        
        for i, instruction in enumerate(instructions):
            instruction_text = font.render(instruction, 1, (255, 255, 255))
            instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * i)
            self.music_option_texts.append((instruction_text, instruction_pos))
        
        for i, music_option_name in enumerate(self.music_option_names):
            music_option_text = font.render(music_option_name, 1, (0, 255, 255))
            music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (i+ len(instructions)))
            self.music_option_texts.append((music_option_text, music_option_pos))
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
        
                # Trong vòng lặp sự kiện, khi người chơi click chuột:
                if event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = pygame.mouse.get_pos()
                    for i, (music_option_text, music_option_pos) in enumerate(self.music_option_texts[len(instructions):]):
                        if music_option_pos.collidepoint(x, y):
                            pygame.mixer.music.load(self.music_options[i])
                            pygame.mixer.music.play(-1)
                            # Đặt lại trạng thái của tất cả các lựa chọn nhạc
                            self.music_option_states = [False] * len(self.music_option_names)
                            # Đặt trạng thái của lựa chọn nhạc này thành True
                            self.music_option_states[i] = True
                            # Cập nhật màu sắc của tất cả các lựa chọn nhạc
                            for j, music_option_name in enumerate(self.music_option_names):
                                color = YELLOW if self.music_option_states[j] else (0, 255, 255)
                                music_option_text = font.render(music_option_name, 1, color)
                                music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (j+ len(instructions)))
                                self.music_option_texts[j + len(instructions)] = (music_option_text, music_option_pos)
        
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        if not pygame.mixer.music.get_busy():  # Kiểm tra xem có nhạc đang chạy không
                            pygame.mixer.music.load(self.music_options[0])  # Ko chọn thì mặc định chạy nhạc 0
                            pygame.mixer.music.set_volume(0)
                            pygame.mixer.music.play(-1)
                        return   

            self.screen.fill((OPTIONAL))

            for music_option_text, music_option_pos in self.music_option_texts:
                self.screen.blit(music_option_text, music_option_pos)

            pygame.display.flip()
    


    def startGame(self):  
            
        self.mazedata.loadMaze(self.level)
        self.mazesprites = MazeSprites(self.mazedata.obj.name+".txt", self.mazedata.obj.name+"_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.mazedata.obj.setPortalPairs(self.nodes)
        self.mazedata.obj.connectHomeNodes(self.nodes)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(*self.mazedata.obj.pacmanStart))
        self.pellets = PelletGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)

        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(0, 3)))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(4, 3)))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 0)))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.mazedata.obj.denyGhostsAccess(self.ghosts, self.nodes)

    # def startGame_old(self):      
    #     self.mazedata.loadMaze(self.level)#######
    #     self.mazesprites = MazeSprites("maze1.txt", "maze1_rotation.txt")
    #     self.setBackground()
    #     self.nodes = NodeGroup("maze1.txt")
    #     self.nodes.setPortalPair((0,17), (27,17))
    #     homekey = self.nodes.createHomeNodes(11.5, 14)
    #     self.nodes.connectHomeNodes(homekey, (12,14), LEFT)
    #     self.nodes.connectHomeNodes(homekey, (15,14), RIGHT)
    #     self.pacman = Pacman(self.nodes.getNodeFromTiles(15, 26))
    #     self.pellets = PelletGroup("maze1.txt")
    #     self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)
    #     self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 0+14))
    #     self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))
    #     self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(0+11.5, 3+14))
    #     self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(4+11.5, 3+14))
    #     self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))

    #     self.nodes.denyHomeAccess(self.pacman)
    #     self.nodes.denyHomeAccessList(self.ghosts)
    #     self.nodes.denyAccessList(2+11.5, 3+14, LEFT, self.ghosts)
    #     self.nodes.denyAccessList(2+11.5, 3+14, RIGHT, self.ghosts)
    #     self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
    #     self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
    #     self.nodes.denyAccessList(12, 14, UP, self.ghosts)
    #     self.nodes.denyAccessList(15, 14, UP, self.ghosts)
    #     self.nodes.denyAccessList(12, 26, UP, self.ghosts)
    #     self.nodes.denyAccessList(15, 26, UP, self.ghosts)

        

    def update(self):
        dt = self.clock.tick(30) / 800.0
        self.textgroup.update(dt)
        self.pellets.update(dt)
        if not self.pause.paused:
            self.ghosts.update(dt)      
            if self.fruit is not None:
                self.fruit.update(dt)
            self.checkPelletEvents()
            self.checkGhostEvents()
            self.checkFruitEvents()

        if self.pacman.alive:
            if not self.pause.paused:
                self.pacman.update(dt)
        else:
            self.pacman.update(dt)

        if self.flashBG:
            self.flashTimer += dt
            if self.flashTimer >= self.flashTime:
                self.flashTimer = 0
                if self.background == self.background_norm:
                    self.background = self.background_flash
                else:
                    self.background = self.background_norm

        afterPauseMethod = self.pause.update(dt)
        if afterPauseMethod is not None:
            afterPauseMethod()
        self.checkEvents()
        self.render()

    def checkEvents(self):
        for event in pygame.event.get():
            if event.type == QUIT:
                exit()
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    if self.pacman.alive:
                        self.pause.setPause(playerPaused=True)
                        if not self.pause.paused:
                            self.textgroup.hideText()
                            self.showEntities()
                        else:
                            self.textgroup.showText(PAUSETXT)
                            #self.hideEntities()

    def checkPelletEvents(self):
        pellet = self.pacman.eatPellets(self.pellets.pelletList)
        if pellet:
            self.pellets.numEaten += 1
            self.updateScore(pellet.points)
            if self.pellets.numEaten == 30:
                self.ghosts.inky.startNode.allowAccess(RIGHT, self.ghosts.inky)
            if self.pellets.numEaten == 70:
                self.ghosts.clyde.startNode.allowAccess(LEFT, self.ghosts.clyde)
            self.pellets.pelletList.remove(pellet)
            if pellet.name == POWERPELLET:
                effect_sound = pygame.mixer.Sound("Pacman_NgThienBao/WAKUWAKU.mp3")
                effect_sound.play()
                self.ghosts.startFreight()
            if self.pellets.isEmpty():
                self.flashBG = True
                self.hideEntities()
                self.pause.setPause(pauseTime=3, func=self.nextLevel)
                
              
    def checkGhostEvents(self):
        for ghost in self.ghosts:
            if self.pacman.collideGhost(ghost):
                if ghost.mode.current is FREIGHT:
                    effect_sound = pygame.mixer.Sound("Pacman_NgThienBao/WAKUWAKU.mp3")
                    effect_sound.play()
                    
                    self.pacman.visible = False
                    ghost.visible = False
                    self.updateScore(ghost.points)                  
                    self.textgroup.addText(str(ghost.points), WHITE, ghost.position.x, ghost.position.y, 8, time=1)
                    self.ghosts.updatePoints()
                    self.pause.setPause(pauseTime=1, func=self.showEntities)
                    ghost.startSpawn()
                    self.nodes.allowHomeAccess(ghost)
                elif ghost.mode.current is not SPAWN:
                    if self.pacman.alive:
                        self.lives -=  1
                        self.lifesprites.removeImage()
                        self.pacman.die()               
                        self.ghosts.hide()
                        if self.lives <= 0:
                            self.textgroup.showText(GAMEOVERTXT)
                            self.pause.setPause(pauseTime=3, func=self.restartGame)
                        else:
                            self.pause.setPause(pauseTime=3, func=self.resetLevel)
    
    def checkFruitEvents(self):
        if self.pellets.numEaten == 50 or self.pellets.numEaten == 140:
            if self.fruit is None:
                self.fruit = Fruit(self.nodes.getNodeFromTiles(9, 20), self.level)
                print(self.fruit)
        if self.fruit is not None:
            if self.pacman.collideCheck(self.fruit):
                self.updateScore(self.fruit.points)
                self.textgroup.addText(str(self.fruit.points), WHITE, self.fruit.position.x, self.fruit.position.y, 8, time=1)
                fruitCaptured = False
                for fruit in self.fruitCaptured:
                    if fruit.get_offset() == self.fruit.image.get_offset():
                        fruitCaptured = True
                        break
                if not fruitCaptured:
                    self.fruitCaptured.append(self.fruit.image)
                self.fruit = None
            elif self.fruit.destroy:
                self.fruit = None

    def showEntities(self):
        self.pacman.visible = True
        self.ghosts.show()

    def hideEntities(self):
        self.pacman.visible = False
        self.ghosts.hide()

    def nextLevel(self):
        self.showEntities()
        self.level += 1
        self.pause.paused = True
        self.startGame()
        self.textgroup.updateLevel(self.level)

    def restartGame(self):
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3")
        pygame.mixer.music.play(1)
        self.lives = 1
        self.level = 0
        self.pause.paused = True
        self.fruit = None
        self.startGame()
        self.score = 0
        self.textgroup.updateScore(self.score)
        self.textgroup.updateLevel(self.level)
        self.textgroup.showText(READYTXT)
        self.lifesprites.resetLives(self.lives)
        self.fruitCaptured = []

    def resetLevel(self):
        self.pause.paused = True
        self.pacman.reset()
        self.ghosts.reset()
        self.fruit = None
        self.textgroup.showText(READYTXT)

    def updateScore(self, points):
        self.score += points
        self.textgroup.updateScore(self.score)

    def render(self):
        self.screen.blit(self.background, (0, 0))
        #self.nodes.render(self.screen)
        self.pellets.render(self.screen)
        if self.fruit is not None:
            self.fruit.render(self.screen)
        self.pacman.render(self.screen)
        self.ghosts.render(self.screen)
        self.textgroup.render(self.screen)

        for i in range(len(self.lifesprites.images)):
            x = self.lifesprites.images[i].get_width() * i
            y = SCREENHEIGHT - self.lifesprites.images[i].get_height()
            self.screen.blit(self.lifesprites.images[i], (x, y))

        for i in range(len(self.fruitCaptured)):
            x = SCREENWIDTH - self.fruitCaptured[i].get_width() * (i+1)
            y = SCREENHEIGHT - self.fruitCaptured[i].get_height()
            self.screen.blit(self.fruitCaptured[i], (x, y))

        pygame.display.update()


if __name__ == "__main__":
    game = GameController()
    game.startScreen()
    game.startScreen2()
    game.startGame()
    
    while game.running:   
        game.update()



//////////////////////





////////////////////////
import pygame
from pygame.locals import *
from constants import *
from sys import *
from pacman import Pacman
from nodes import NodeGroup
from pellets import PelletGroup
from ghosts import GhostGroup
from fruit import Fruit
from pauser import Pause
from text import TextGroup
from sprites import LifeSprites
from sprites import MazeSprites
from mazedata import MazeData

class GameController(object):
    def __init__(self):
        pygame.init()
        pygame.mixer.init()
        #pygame.mixer.music.load("Pacman_NgThienBao/BTS_FAKELOVE.mp3")
        #pygame.mixer.music.set_volume(1.0)
        #pygame.mixer.music.play(-1)
        self.screen = pygame.display.set_mode(SCREENSIZE, 0, 32)
        self.background = None
        self.background_norm = None
        self.background_flash = None
        self.clock = pygame.time.Clock()
        self.fruit = None
        self.pause = Pause(True)
        self.level = 0
        self.lives = 2
        self.score = 0
        self.textgroup = TextGroup()
        self.lifesprites = LifeSprites(self.lives)
        self.flashBG = False
        self.flashTime = 0.2
        self.flashTimer = 0
        self.fruitCaptured = []
        self.fruitNode = None
        self.mazedata = MazeData()
        self.running = True
        
    
        

    def setBackground(self):
        self.background_norm = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_norm.fill(OPTIONAL)
        self.background_flash = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_flash.fill(BLACK)
        self.background_norm = self.mazesprites.constructBackground(self.background_norm, self.level%5)
        self.background_flash = self.mazesprites.constructBackground(self.background_flash, 5)
        self.flashBG = False
        self.background = self.background_norm
        
    
    def startScreen(self):
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        return

            self.screen.fill((0, 250, 255))
            font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 28)
            # text = font.render("Press Space to Start", 1, (255, 255, 255))
            # textpos = text.get_rect(centerx=self.screen.get_width()/2)
            # self.screen.blit(text, textpos)
            
            instructions = ["ĐỒ ÁN CUỐI KỲ DSA","GAME PACMAN","Nguyễn Thiên Bảo","Nhấn Space để tiếp tục"]
            for i, instruction in enumerate(instructions):
                instruction_text = font.render(instruction, 1, (255, 20, 100))
                instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/5 + 60 * (i+1))
                self.screen.blit(instruction_text, instruction_pos)
            
            pygame.display.flip()
            
    def startScreen2(self):
        
        self.music_options = [ "Pacman_NgThienBao/BTS_FAKELOVE.mp3",
                               "Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3",
                               "Pacman_NgThienBao/CAUSEILOVEYOU.mp3",
                               "Pacman_NgThienBao/HARUHARU.mp3",
                               "Pacman_NgThienBao/XICHLINH.mp3",
                               "Pacman_NgThienBao/ATTACKONTITAN1.mp3",
                               "Pacman_NgThienBao/5CMS.mp3"]
        self.music_option_names = ["[Fake Love Orchestral]",
                                   "[Buông Đôi Tay Nhau Ra]",
                                   "[Cause I Love You]",
                                   "[BigBang-Haru Haru]",
                                   "[Xích Linh Remix]",
                                   "[Attack On Titan]",
                                   "[5 Cm/s]"]
        self.music_option_texts = []
        
        font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 20)

        instructions = ["Click chuột để chọn nhạc, có thể không chọn", "Nhấn Space để chơi và tạm dừng", "Giữ nút mũi tên để di chuyển"]
        # Khởi tạo một danh sách để lưu trữ trạng thái của từng lựa chọn nhạc
        self.music_option_states = [False] * len(self.music_option_names)
        
        for i, instruction in enumerate(instructions):
            instruction_text = font.render(instruction, 1, (255, 255, 255))
            instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * i)
            self.music_option_texts.append((instruction_text, instruction_pos))
        
        for i, music_option_name in enumerate(self.music_option_names):
            music_option_text = font.render(music_option_name, 1, (0, 255, 255))
            music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (i+ len(instructions)))
            self.music_option_texts.append((music_option_text, music_option_pos))
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
        
                # Trong vòng lặp sự kiện, khi người chơi click chuột:
                if event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = pygame.mouse.get_pos()
                    for i, (music_option_text, music_option_pos) in enumerate(self.music_option_texts[len(instructions):]):
                        if music_option_pos.collidepoint(x, y):
                            pygame.mixer.music.load(self.music_options[i])
                            pygame.mixer.music.play(-1)
                            # Đặt lại trạng thái của tất cả các lựa chọn nhạc
                            self.music_option_states = [False] * len(self.music_option_names)
                            # Đặt trạng thái của lựa chọn nhạc này thành True
                            self.music_option_states[i] = True
                            # Cập nhật màu sắc của tất cả các lựa chọn nhạc
                            for j, music_option_name in enumerate(self.music_option_names):
                                color = YELLOW if self.music_option_states[j] else (0, 255, 255)
                                music_option_text = font.render(music_option_name, 1, color)
                                music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (j+ len(instructions)))
                                self.music_option_texts[j + len(instructions)] = (music_option_text, music_option_pos)
        
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        if not pygame.mixer.music.get_busy():  # Kiểm tra xem có nhạc đang chạy không
                            pygame.mixer.music.load(self.music_options[0])  # Ko chọn thì mặc định chạy nhạc 0
                            pygame.mixer.music.set_volume(0)
                            pygame.mixer.music.play(-1)
                        return   

            self.screen.fill((OPTIONAL))

            for music_option_text, music_option_pos in self.music_option_texts:
                self.screen.blit(music_option_text, music_option_pos)

            pygame.display.flip()
    


    def startGame(self):  
            
        self.mazedata.loadMaze(self.level)
        self.mazesprites = MazeSprites(self.mazedata.obj.name+".txt", self.mazedata.obj.name+"_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.mazedata.obj.setPortalPairs(self.nodes)
        self.mazedata.obj.connectHomeNodes(self.nodes)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(*self.mazedata.obj.pacmanStart))
        self.pellets = PelletGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)

        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(0, 3)))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(4, 3)))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 0)))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.mazedata.obj.denyGhostsAccess(self.ghosts, self.nodes)

    # def startGame_old(self):      
    #     self.mazedata.loadMaze(self.level)#######
    #     self.mazesprites = MazeSprites("maze1.txt", "maze1_rotation.txt")
    #     self.setBackground()
    #     self.nodes = NodeGroup("maze1.txt")
    #     self.nodes.setPortalPair((0,17), (27,17))
    #     homekey = self.nodes.createHomeNodes(11.5, 14)
    #     self.nodes.connectHomeNodes(homekey, (12,14), LEFT)
    #     self.nodes.connectHomeNodes(homekey, (15,14), RIGHT)
    #     self.pacman = Pacman(self.nodes.getNodeFromTiles(15, 26))
    #     self.pellets = PelletGroup("maze1.txt")
    #     self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)
    #     self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 0+14))
    #     self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))
    #     self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(0+11.5, 3+14))
    #     self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(4+11.5, 3+14))
    #     self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(2+11.5, 3+14))

    #     self.nodes.denyHomeAccess(self.pacman)
    #     self.nodes.denyHomeAccessList(self.ghosts)
    #     self.nodes.denyAccessList(2+11.5, 3+14, LEFT, self.ghosts)
    #     self.nodes.denyAccessList(2+11.5, 3+14, RIGHT, self.ghosts)
    #     self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
    #     self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
    #     self.nodes.denyAccessList(12, 14, UP, self.ghosts)
    #     self.nodes.denyAccessList(15, 14, UP, self.ghosts)
    #     self.nodes.denyAccessList(12, 26, UP, self.ghosts)
    #     self.nodes.denyAccessList(15, 26, UP, self.ghosts)

        

    def update(self):
        dt = self.clock.tick(30) / 800.0
        self.textgroup.update(dt)
        self.pellets.update(dt)
        if not self.pause.paused:
            self.ghosts.update(dt)      
            if self.fruit is not None:
                self.fruit.update(dt)
            self.checkPelletEvents()
            self.checkGhostEvents()
            self.checkFruitEvents()

        if self.pacman.alive:
            if not self.pause.paused:
                self.pacman.update(dt)
        else:
            self.pacman.update(dt)

        if self.flashBG:
            self.flashTimer += dt
            if self.flashTimer >= self.flashTime:
                self.flashTimer = 0
                if self.background == self.background_norm:
                    self.background = self.background_flash
                else:
                    self.background = self.background_norm

        afterPauseMethod = self.pause.update(dt)
        if afterPauseMethod is not None:
            afterPauseMethod()
        self.checkEvents()
        self.render()

    def checkEvents(self):
        for event in pygame.event.get():
            if event.type == QUIT:
                exit()
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    if self.pacman.alive:
                        self.pause.setPause(playerPaused=True)
                        if not self.pause.paused:
                            self.textgroup.hideText()
                            self.showEntities()
                        else:
                            self.textgroup.showText(PAUSETXT)
                            #self.hideEntities()

    def checkPelletEvents(self):
        pellet = self.pacman.eatPellets(self.pellets.pelletList)
        if pellet:
            self.pellets.numEaten += 1
            self.updateScore(pellet.points)
            if self.pellets.numEaten == 30:
                self.ghosts.inky.startNode.allowAccess(RIGHT, self.ghosts.inky)
            if self.pellets.numEaten == 70:
                self.ghosts.clyde.startNode.allowAccess(LEFT, self.ghosts.clyde)
            self.pellets.pelletList.remove(pellet)
            if pellet.name == POWERPELLET:
                effect_sound = pygame.mixer.Sound("Pacman_NgThienBao/WAKUWAKU.mp3")
                effect_sound.play()
                self.ghosts.startFreight()
            if self.pellets.isEmpty():
                self.flashBG = True
                self.hideEntities()
                self.pause.setPause(pauseTime=3, func=self.nextLevel)
                
              
    def checkGhostEvents(self):
        for ghost in self.ghosts:
            if self.pacman.collideGhost(ghost):
                if ghost.mode.current is FREIGHT:
                    effect_sound = pygame.mixer.Sound("Pacman_NgThienBao/WAKUWAKU.mp3")
                    effect_sound.play()
                    
                    self.pacman.visible = False
                    ghost.visible = False
                    self.updateScore(ghost.points)                  
                    self.textgroup.addText(str(ghost.points), WHITE, ghost.position.x, ghost.position.y, 8, time=1)
                    self.ghosts.updatePoints()
                    self.pause.setPause(pauseTime=1, func=self.showEntities)
                    ghost.startSpawn()
                    self.nodes.allowHomeAccess(ghost)
                elif ghost.mode.current is not SPAWN:
                    if self.pacman.alive:
                        self.lives -=  1
                        self.lifesprites.removeImage()
                        self.pacman.die()               
                        self.ghosts.hide()
                        if self.lives <= 0:
                            self.textgroup.showText(GAMEOVERTXT)
                            self.pause.setPause(pauseTime=3, func=self.restartGame)
                        else:
                            self.pause.setPause(pauseTime=3, func=self.resetLevel)
    
    def checkFruitEvents(self):
        if self.pellets.numEaten == 50 or self.pellets.numEaten == 140:
            if self.fruit is None:
                self.fruit = Fruit(self.nodes.getNodeFromTiles(9, 20), self.level)
                print(self.fruit)
        if self.fruit is not None:
            if self.pacman.collideCheck(self.fruit):
                self.updateScore(self.fruit.points)
                self.textgroup.addText(str(self.fruit.points), WHITE, self.fruit.position.x, self.fruit.position.y, 8, time=1)
                fruitCaptured = False
                for fruit in self.fruitCaptured:
                    if fruit.get_offset() == self.fruit.image.get_offset():
                        fruitCaptured = True
                        break
                if not fruitCaptured:
                    self.fruitCaptured.append(self.fruit.image)
                self.fruit = None
            elif self.fruit.destroy:
                self.fruit = None

    def showEntities(self):
        self.pacman.visible = True
        self.ghosts.show()

    def hideEntities(self):
        self.pacman.visible = False
        self.ghosts.hide()

    def nextLevel(self):
        self.showEntities()
        self.level += 1
        self.pause.paused = True
        self.startGame()
        self.textgroup.updateLevel(self.level)

    def restartGame(self):
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3")
        pygame.mixer.music.play(1)
        self.lives = 1
        self.level = 0
        self.pause.paused = True
        self.fruit = None
        self.startGame()
        self.score = 0
        self.textgroup.updateScore(self.score)
        self.textgroup.updateLevel(self.level)
        self.textgroup.showText(READYTXT)
        self.lifesprites.resetLives(self.lives)
        self.fruitCaptured = []

    def resetLevel(self):
        self.pause.paused = True
        self.pacman.reset()
        self.ghosts.reset()
        self.fruit = None
        self.textgroup.showText(READYTXT)

    def updateScore(self, points):
        self.score += points
        self.textgroup.updateScore(self.score)

    def render(self):
        self.screen.blit(self.background, (0, 0))
        #self.nodes.render(self.screen)
        self.pellets.render(self.screen)
        if self.fruit is not None:
            self.fruit.render(self.screen)
        self.pacman.render(self.screen)
        self.ghosts.render(self.screen)
        self.textgroup.render(self.screen)

        for i in range(len(self.lifesprites.images)):
            x = self.lifesprites.images[i].get_width() * i
            y = SCREENHEIGHT - self.lifesprites.images[i].get_height()
            self.screen.blit(self.lifesprites.images[i], (x, y))

        for i in range(len(self.fruitCaptured)):
            x = SCREENWIDTH - self.fruitCaptured[i].get_width() * (i+1)
            y = SCREENHEIGHT - self.fruitCaptured[i].get_height()
            self.screen.blit(self.fruitCaptured[i], (x, y))

        pygame.display.update()


if __name__ == "__main__":
    game = GameController()
    game.startScreen()
    game.startScreen2()
    game.startGame()
    
    while game.running:   
        game.update()




        //////////////////////////////
         



         /////////////////////////////////
import pygame
from pygame.locals import *
from constants import *
from sys import *
from pacman import Pacman
from nodes import NodeGroup
from pellets import PelletGroup
from ghosts import GhostGroup
from fruit import Fruit
from pauser import Pause
from text import TextGroup
from sprites import LifeSprites
from sprites import MazeSprites
from mazedata import MazeData

class GameController(object):
    def __init__(self):
        pygame.init()
        pygame.mixer.init()
        #pygame.mixer.music.load("Pacman_NgThienBao/BTS_FAKELOVE.mp3")
        #pygame.mixer.music.set_volume(1.0)
        #pygame.mixer.music.play(-1)
        self.screen = pygame.display.set_mode(SCREENSIZE, 0, 32)
        self.background = None
        self.background_norm = None
        self.background_flash = None
        self.clock = pygame.time.Clock()
        self.fruit = None
        self.pause = Pause(True)
        self.level = 0
        self.lives = 2
        self.score = 0
        self.textgroup = TextGroup()
        self.lifesprites = LifeSprites(self.lives)
        self.flashBG = False
        self.flashTime = 0.2
        self.flashTimer = 0
        self.fruitCaptured = []
        self.fruitNode = None
        self.mazedata = MazeData()
        self.running = True
        self.high_score = 0
    
        

    def setBackground(self):
        self.background_norm = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_norm.fill(OPTIONAL)
        self.background_flash = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_flash.fill(BLACK)
        self.background_norm = self.mazesprites.constructBackground(self.background_norm, self.level%5)
        self.background_flash = self.mazesprites.constructBackground(self.background_flash, 5)
        self.flashBG = False
        self.background = self.background_norm
        
    
    def startScreen(self):
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        return

            self.screen.fill((0, 250, 255))
            font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 28)
            
            instructions = ["ĐỒ ÁN CUỐI KỲ DSA","GAME PACMAN","Nguyễn Thiên Bảo","Nhấn Space để tiếp tục"]
            for i, instruction in enumerate(instructions):
                instruction_text = font.render(instruction, 1, (255, 20, 100))
                instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/5 + 60 * (i+1))
                self.screen.blit(instruction_text, instruction_pos)
            
            pygame.display.flip()
            
    def startScreen2(self):
        
        self.music_options = [ "Pacman_NgThienBao/BTS_FAKELOVE.mp3",
                               "Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3",
                               "Pacman_NgThienBao/CAUSEILOVEYOU.mp3",
                               "Pacman_NgThienBao/HARUHARU.mp3",
                               "Pacman_NgThienBao/XICHLINH.mp3",
                               "Pacman_NgThienBao/ATTACKONTITAN1.mp3",
                               "Pacman_NgThienBao/5CMS.mp3"]
        self.music_option_names = ["[Fake Love Orchestral]",
                                   "[Buông Đôi Tay Nhau Ra]",
                                   "[Cause I Love You]",
                                   "[BigBang-Haru Haru]",
                                   "[Xích Linh Remix]",
                                   "[Attack On Titan]",
                                   "[5 Cm/s]"]
        self.music_option_texts = []
        
        font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 20)

        instructions = ["Click chuột để chọn nhạc, có thể không chọn", "Nhấn Space để chơi và tạm dừng", "Giữ nút mũi tên để di chuyển"]
        # Khởi tạo một danh sách để lưu trữ trạng thái của từng lựa chọn nhạc
        self.music_option_states = [False] * len(self.music_option_names)
        
        for i, instruction in enumerate(instructions):
            instruction_text = font.render(instruction, 1, (255, 255, 255))
            instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * i)
            self.music_option_texts.append((instruction_text, instruction_pos))
        
        for i, music_option_name in enumerate(self.music_option_names):
            music_option_text = font.render(music_option_name, 1, (0, 255, 255))
            music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (i+ len(instructions)))
            self.music_option_texts.append((music_option_text, music_option_pos))
            
        high_score_text = font.render(f"Highest Score: {self.high_score}", 1, (100, 255, 100))
        high_score_pos = high_score_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (len(self.music_option_names) + len(instructions)))
        self.music_option_texts.append((high_score_text, high_score_pos))
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
        
                # Trong vòng lặp sự kiện, khi người chơi click chuột:
                if event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = pygame.mouse.get_pos()
                    for i, (music_option_text, music_option_pos) in enumerate(self.music_option_texts[len(instructions):]):
                        if music_option_pos.collidepoint(x, y):
                            if i < len(self.music_options):  # Kiểm tra xem người dùng có click vào một tùy chọn nhạc hay không
                                pygame.mixer.music.load(self.music_options[i])
                                pygame.mixer.music.play(-1)
                                # Đặt lại trạng thái của tất cả các lựa chọn nhạc
                                self.music_option_states = [False] * len(self.music_option_names)
                                # Đặt trạng thái của lựa chọn nhạc này thành True
                                self.music_option_states[i] = True
                                # Cập nhật màu sắc của tất cả các lựa chọn nhạc
                                for j, music_option_name in enumerate(self.music_option_names):
                                    color = YELLOW if self.music_option_states[j] else (0, 255, 255)
                                    music_option_text = font.render(music_option_name, 1, color)
                                    music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (j+ len(instructions)))
                                    self.music_option_texts[j + len(instructions)] = (music_option_text, music_option_pos)
        
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        if not pygame.mixer.music.get_busy():  # Kiểm tra xem có nhạc đang chạy không
                            pygame.mixer.music.load(self.music_options[0])  # Ko chọn thì mặc định chạy nhạc 0
                            pygame.mixer.music.set_volume(0)
                            pygame.mixer.music.play(-1)
                        return   

            self.screen.fill((OPTIONAL))

            for music_option_text, music_option_pos in self.music_option_texts:
                self.screen.blit(music_option_text, music_option_pos)

            pygame.display.flip()
        
    


    def startGame(self):  
            
        self.mazedata.loadMaze(self.level)
        self.mazesprites = MazeSprites(self.mazedata.obj.name+".txt", self.mazedata.obj.name+"_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.mazedata.obj.setPortalPairs(self.nodes)
        self.mazedata.obj.connectHomeNodes(self.nodes)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(*self.mazedata.obj.pacmanStart))
        self.pellets = PelletGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)

        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(0, 3)))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(4, 3)))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 0)))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.mazedata.obj.denyGhostsAccess(self.ghosts, self.nodes)
 
    def update(self):
        dt = self.clock.tick(30) / 800.0
        self.textgroup.update(dt)
        self.pellets.update(dt)
        if not self.pause.paused:
            self.ghosts.update(dt)      
            if self.fruit is not None:
                self.fruit.update(dt)
            self.checkPelletEvents()
            self.checkGhostEvents()
            self.checkFruitEvents()

        if self.pacman.alive:
            if not self.pause.paused:
                self.pacman.update(dt)
        else:
            self.pacman.update(dt)

        if self.flashBG:
            self.flashTimer += dt
            if self.flashTimer >= self.flashTime:
                self.flashTimer = 0
                if self.background == self.background_norm:
                    self.background = self.background_flash
                else:
                    self.background = self.background_norm

        afterPauseMethod = self.pause.update(dt)
        if afterPauseMethod is not None:
            afterPauseMethod()
        self.checkEvents()
        self.render()

    def checkEvents(self):
        for event in pygame.event.get():
            if event.type == QUIT:
                exit()
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    if self.pacman.alive:
                        self.pause.setPause(playerPaused=True)
                        if not self.pause.paused:
                            self.textgroup.hideText()
                            self.showEntities()
                        else:
                            self.textgroup.showText(PAUSETXT)
                            #self.hideEntities()

    def checkPelletEvents(self):
        pellet = self.pacman.eatPellets(self.pellets.pelletList)
        if pellet:
            self.pellets.numEaten += 1
            self.updateScore(pellet.points)
            if self.pellets.numEaten == 30:
                self.ghosts.inky.startNode.allowAccess(RIGHT, self.ghosts.inky)
            if self.pellets.numEaten == 70:
                self.ghosts.clyde.startNode.allowAccess(LEFT, self.ghosts.clyde)
            self.pellets.pelletList.remove(pellet)
            if pellet.name == POWERPELLET:
                effect_sound = pygame.mixer.Sound("Pacman_NgThienBao/WAKUWAKU.mp3")
                effect_sound.play()
                self.ghosts.startFreight()
            if self.pellets.isEmpty():
                self.flashBG = True
                self.hideEntities()
                self.pause.setPause(pauseTime=3, func=self.nextLevel)
                
              
    def checkGhostEvents(self):
        for ghost in self.ghosts:
            if self.pacman.collideGhost(ghost):
                if ghost.mode.current is FREIGHT:
                    effect_sound = pygame.mixer.Sound("Pacman_NgThienBao/WAKUWAKU.mp3")
                    effect_sound.play()
                    
                    self.pacman.visible = False
                    ghost.visible = False
                    self.updateScore(ghost.points)                  
                    self.textgroup.addText(str(ghost.points), WHITE, ghost.position.x, ghost.position.y, 8, time=1)
                    self.ghosts.updatePoints()
                    self.pause.setPause(pauseTime=1, func=self.showEntities)
                    ghost.startSpawn()
                    self.nodes.allowHomeAccess(ghost)
                elif ghost.mode.current is not SPAWN:
                    if self.pacman.alive:
                        self.lives -=  1
                        self.lifesprites.removeImage()
                        self.pacman.die()               
                        self.ghosts.hide()
                        if self.lives <= 0:
                            pygame.mixer.music.stop()
                            self.textgroup.showText(GAMEOVERTXT)
                            self.pause.setPause(pauseTime=3, func=self.restartGame)
                            self.high_score = max(self.score, self.high_score)
                        else:
                            self.pause.setPause(pauseTime=3, func=self.resetLevel)
                            
        
    def checkFruitEvents(self):
        if self.pellets.numEaten == 50 or self.pellets.numEaten == 140:
            if self.fruit is None:
                self.fruit = Fruit(self.nodes.getNodeFromTiles(9, 20), self.level)
                print(self.fruit)
        if self.fruit is not None:
            if self.pacman.collideCheck(self.fruit):
                self.updateScore(self.fruit.points)
                self.textgroup.addText(str(self.fruit.points), WHITE, self.fruit.position.x, self.fruit.position.y, 8, time=1)
                fruitCaptured = False
                for fruit in self.fruitCaptured:
                    if fruit.get_offset() == self.fruit.image.get_offset():
                        fruitCaptured = True
                        break
                if not fruitCaptured:
                    self.fruitCaptured.append(self.fruit.image)
                self.fruit = None
            elif self.fruit.destroy:
                self.fruit = None

    def showEntities(self):
        self.pacman.visible = True
        self.ghosts.show()

    def hideEntities(self):
        self.pacman.visible = False
        self.ghosts.hide()

    def nextLevel(self):
        self.showEntities()
        self.level += 1
        self.pause.paused = True
        self.startGame()
        self.textgroup.updateLevel(self.level)

    def restartGame(self):
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3")
        self.startScreen2()
        self.lives = 1
        self.level = 0
        self.pause.paused = True
        self.fruit = None
        self.startGame()
        self.score = 0
        self.textgroup.updateScore(self.score)
        self.textgroup.updateLevel(self.level)
        self.textgroup.showText(READYTXT)
        self.lifesprites.resetLives(self.lives)
        self.fruitCaptured = []

    def resetLevel(self):
        self.pause.paused = True
        self.pacman.reset()
        self.ghosts.reset()
        self.fruit = None
        self.textgroup.showText(READYTXT)

    def updateScore(self, points):
        self.score += points
        self.textgroup.updateScore(self.score)

    def render(self):
        self.screen.blit(self.background, (0, 0))
        #self.nodes.render(self.screen)
        self.pellets.render(self.screen)
        if self.fruit is not None:
            self.fruit.render(self.screen)
        self.pacman.render(self.screen)
        self.ghosts.render(self.screen)
        self.textgroup.render(self.screen)

        for i in range(len(self.lifesprites.images)):
            x = self.lifesprites.images[i].get_width() * i
            y = SCREENHEIGHT - self.lifesprites.images[i].get_height()
            self.screen.blit(self.lifesprites.images[i], (x, y))

        for i in range(len(self.fruitCaptured)):
            x = SCREENWIDTH - self.fruitCaptured[i].get_width() * (i+1)
            y = SCREENHEIGHT - self.fruitCaptured[i].get_height()
            self.screen.blit(self.fruitCaptured[i], (x, y))

        pygame.display.update()


if __name__ == "__main__":
    game = GameController()
    game.startScreen()
    game.startScreen2()
    game.startGame()
    
    while game.running:   
        game.update()




////////////////////////////



//////////////////////////////
/////////
import pygame
from pygame.locals import *
from constants import *
from sys import *
from pacman import Pacman
from nodes import NodeGroup
from pellets import PelletGroup
from ghosts import GhostGroup
from fruit import Fruit
from pauser import Pause
from text import TextGroup
from sprites import LifeSprites
from sprites import MazeSprites
from mazedata import MazeData

class GameController(object):
    def __init__(self):
        pygame.init()
        pygame.mixer.init()
        #pygame.mixer.music.load("Pacman_NgThienBao/BTS_FAKELOVE.mp3")
        #pygame.mixer.music.set_volume(1.0)
        #pygame.mixer.music.play(-1)
        self.screen = pygame.display.set_mode(SCREENSIZE, 0, 32)
        self.background = None
        self.background_norm = None
        self.background_flash = None
        self.clock = pygame.time.Clock()
        self.fruit = None
        self.pause = Pause(True)
        self.level = 0
        self.lives = 2
        self.score = 0
        self.textgroup = TextGroup()
        self.lifesprites = LifeSprites(self.lives)
        self.flashBG = False
        self.flashTime = 0.2
        self.flashTimer = 0
        self.fruitCaptured = []
        self.fruitNode = None
        self.mazedata = MazeData()
        self.running = True
        self.high_score = 0
    
        

    def setBackground(self):
        self.background_norm = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_norm.fill(OPTIONAL)
        self.background_flash = pygame.surface.Surface(SCREENSIZE).convert()
        self.background_flash.fill(BLACK)
        self.background_norm = self.mazesprites.constructBackground(self.background_norm, self.level%5)
        self.background_flash = self.mazesprites.constructBackground(self.background_flash, 5)
        self.flashBG = False
        self.background = self.background_norm
        
    
    def startScreen(self):
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        return

            self.screen.fill((0, 250, 255))
            font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 28)
            
            instructions = ["ĐỒ ÁN CUỐI KỲ DSA","GAME PACMAN","Nguyễn Thiên Bảo","Nhấn Space để tiếp tục"]
            for i, instruction in enumerate(instructions):
                instruction_text = font.render(instruction, 1, (255, 20, 100))
                instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/5 + 60 * (i+1))
                self.screen.blit(instruction_text, instruction_pos)
            
            pygame.display.flip()
            
    def startScreen2(self):
        
        self.music_options = [ "Pacman_NgThienBao/BTS_FAKELOVE.mp3",
                               "Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3",
                               "Pacman_NgThienBao/CAUSEILOVEYOU.mp3",
                               "Pacman_NgThienBao/HARUHARU.mp3",
                               "Pacman_NgThienBao/XICHLINH.mp3",
                               "Pacman_NgThienBao/ATTACKONTITAN1.mp3",
                               "Pacman_NgThienBao/5CMS.mp3"]
        self.music_option_names = ["[Fake Love Orchestral]",
                                   "[Buông Đôi Tay Nhau Ra]",
                                   "[Cause I Love You]",
                                   "[BigBang-Haru Haru]",
                                   "[Xích Linh Remix]",
                                   "[Attack On Titan]",
                                   "[5 Cm/s]"]
        self.music_option_texts = []
        
        font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 20)

        instructions = ["Click chuột để chọn nhạc, có thể không chọn", "Nhấn Space để chơi và tạm dừng", "Giữ nút mũi tên để di chuyển"]
        # Khởi tạo một danh sách để lưu trữ trạng thái của từng lựa chọn nhạc
        self.music_option_states = [False] * len(self.music_option_names)
        
        for i, instruction in enumerate(instructions):
            instruction_text = font.render(instruction, 1, (255, 255, 255))
            instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * i)
            self.music_option_texts.append((instruction_text, instruction_pos))
        
        for i, music_option_name in enumerate(self.music_option_names):
            music_option_text = font.render(music_option_name, 1, (0, 255, 255))
            music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (i+ len(instructions)))
            self.music_option_texts.append((music_option_text, music_option_pos))
            
        high_score_text = font.render(f"Highest Score: {self.high_score}", 1, (100, 255, 100))
        high_score_pos = high_score_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (len(self.music_option_names) + len(instructions)))
        self.music_option_texts.append((high_score_text, high_score_pos))
        
        while self.running:
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
        
                # Trong vòng lặp sự kiện, khi người chơi click chuột:
                if event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = pygame.mouse.get_pos()
                    for i, (music_option_text, music_option_pos) in enumerate(self.music_option_texts[len(instructions):]):
                        if music_option_pos.collidepoint(x, y):
                            if i < len(self.music_options):  # Kiểm tra xem người dùng có click vào một tùy chọn nhạc hay không
                                pygame.mixer.music.load(self.music_options[i])
                                pygame.mixer.music.set_volume(1)
                                pygame.mixer.music.play(-1)
                                # Đặt lại trạng thái của tất cả các lựa chọn nhạc
                                self.music_option_states = [False] * len(self.music_option_names)
                                # Đặt trạng thái của lựa chọn nhạc này thành True
                                self.music_option_states[i] = True
                                # Cập nhật màu sắc của tất cả các lựa chọn nhạc
                                for j, music_option_name in enumerate(self.music_option_names):
                                    color = YELLOW if self.music_option_states[j] else (0, 255, 255)
                                    music_option_text = font.render(music_option_name, 1, color)
                                    music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (j+ len(instructions)))
                                    self.music_option_texts[j + len(instructions)] = (music_option_text, music_option_pos)
        
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        if not pygame.mixer.music.get_busy():  # Kiểm tra xem có nhạc đang chạy không
                            pygame.mixer.music.load(self.music_options[0])  # Ko chọn thì mặc định chạy nhạc 0
                            pygame.mixer.music.set_volume(0)
                            pygame.mixer.music.play(-1)
                        return   

            self.screen.fill((OPTIONAL))

            for music_option_text, music_option_pos in self.music_option_texts:
                self.screen.blit(music_option_text, music_option_pos)

            pygame.display.flip()
        
    


    def startGame(self):  
            
        self.mazedata.loadMaze(self.level)
        self.mazesprites = MazeSprites(self.mazedata.obj.name+".txt", self.mazedata.obj.name+"_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.mazedata.obj.setPortalPairs(self.nodes)
        self.mazedata.obj.connectHomeNodes(self.nodes)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(*self.mazedata.obj.pacmanStart))
        self.pellets = PelletGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)

        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(0, 3)))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(4, 3)))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 0)))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.mazedata.obj.denyGhostsAccess(self.ghosts, self.nodes)
 
    def update(self):
        dt = self.clock.tick(30) / 800.0
        self.textgroup.update(dt)
        self.pellets.update(dt)
        if not self.pause.paused:
            self.ghosts.update(dt)      
            if self.fruit is not None:
                self.fruit.update(dt)
            self.checkPelletEvents()
            self.checkGhostEvents()
            self.checkFruitEvents()

        if self.pacman.alive:
            if not self.pause.paused:
                self.pacman.update(dt)
        else:
            self.pacman.update(dt)

        if self.flashBG:
            self.flashTimer += dt
            if self.flashTimer >= self.flashTime:
                self.flashTimer = 0
                if self.background == self.background_norm:
                    self.background = self.background_flash
                else:
                    self.background = self.background_norm

        afterPauseMethod = self.pause.update(dt)
        if afterPauseMethod is not None:
            afterPauseMethod()
        self.checkEvents()
        self.render()

    def checkEvents(self):
        for event in pygame.event.get():
            if event.type == QUIT:
                exit()
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    if self.pacman.alive:
                        self.pause.setPause(playerPaused=True)
                        if not self.pause.paused:
                            self.textgroup.hideText()
                            self.showEntities()
                        else:
                            self.textgroup.showText(PAUSETXT)
                            #self.hideEntities()

    def checkPelletEvents(self):
        pellet = self.pacman.eatPellets(self.pellets.pelletList)
        if pellet:
            self.pellets.numEaten += 1
            self.updateScore(pellet.points)
            if self.pellets.numEaten == 30:
                self.ghosts.inky.startNode.allowAccess(RIGHT, self.ghosts.inky)
            if self.pellets.numEaten == 70:
                self.ghosts.clyde.startNode.allowAccess(LEFT, self.ghosts.clyde)
            self.pellets.pelletList.remove(pellet)
            if pellet.name == POWERPELLET:
                effect_sound = pygame.mixer.Sound("Pacman_NgThienBao/WAKUWAKU.mp3")
                effect_sound.play()
                self.ghosts.startFreight()
            if self.pellets.isEmpty():
                self.flashBG = True
                self.hideEntities()
                self.pause.setPause(pauseTime=3, func=self.nextLevel)
                
              
    def checkGhostEvents(self):
        for ghost in self.ghosts:
            if self.pacman.collideGhost(ghost):
                if ghost.mode.current is FREIGHT:
                    effect_sound = pygame.mixer.Sound("Pacman_NgThienBao/WAKUWAKU.mp3")
                    effect_sound.play()
                    
                    self.pacman.visible = False
                    ghost.visible = False
                    self.updateScore(ghost.points)                  
                    self.textgroup.addText(str(ghost.points), WHITE, ghost.position.x, ghost.position.y, 8, time=1)
                    self.ghosts.updatePoints()
                    self.pause.setPause(pauseTime=1, func=self.showEntities)
                    ghost.startSpawn()
                    self.nodes.allowHomeAccess(ghost)
                elif ghost.mode.current is not SPAWN:
                    if self.pacman.alive:
                        self.lives -=  1
                        self.lifesprites.removeImage()
                        self.pacman.die()               
                        self.ghosts.hide()
                        if self.lives <= 0:
                            pygame.mixer.music.stop()
                            self.textgroup.showText(GAMEOVERTXT)
                            self.pause.setPause(pauseTime=3, func=self.restartGame)
                            self.high_score = max(self.score, self.high_score)
                        else:
                            self.pause.setPause(pauseTime=3, func=self.resetLevel)
                            
        
    def checkFruitEvents(self):
        if self.pellets.numEaten == 50 or self.pellets.numEaten == 140:
            if self.fruit is None:
                self.fruit = Fruit(self.nodes.getNodeFromTiles(9, 20), self.level)
                print(self.fruit)
        if self.fruit is not None:
            if self.pacman.collideCheck(self.fruit):
                self.updateScore(self.fruit.points)
                self.textgroup.addText(str(self.fruit.points), WHITE, self.fruit.position.x, self.fruit.position.y, 8, time=1)
                fruitCaptured = False
                for fruit in self.fruitCaptured:
                    if fruit.get_offset() == self.fruit.image.get_offset():
                        fruitCaptured = True
                        break
                if not fruitCaptured:
                    self.fruitCaptured.append(self.fruit.image)
                self.fruit = None
            elif self.fruit.destroy:
                self.fruit = None

    def showEntities(self):
        self.pacman.visible = True
        self.ghosts.show()

    def hideEntities(self):
        self.pacman.visible = False
        self.ghosts.hide()

    def nextLevel(self):
        self.showEntities()
        self.level += 1
        self.pause.paused = True
        self.startGame()
        self.textgroup.updateLevel(self.level)

    def restartGame(self):
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3")
        self.startScreen2()
        self.lives = 1
        self.level = 0
        self.pause.paused = True
        self.fruit = None
        self.startGame()
        self.score = 0
        self.textgroup.updateScore(self.score)
        self.textgroup.updateLevel(self.level)
        self.textgroup.showText(READYTXT)
        self.lifesprites.resetLives(self.lives)
        self.fruitCaptured = []

    def resetLevel(self):
        self.pause.paused = True
        self.pacman.reset()
        self.ghosts.reset()
        self.fruit = None
        self.textgroup.showText(READYTXT)

    def updateScore(self, points):
        self.score += points
        self.textgroup.updateScore(self.score)

    def render(self):
        self.screen.blit(self.background, (0, 0))
        #self.nodes.render(self.screen)
        self.pellets.render(self.screen)
        if self.fruit is not None:
            self.fruit.render(self.screen)
        self.pacman.render(self.screen)
        self.ghosts.render(self.screen)
        self.textgroup.render(self.screen)

        for i in range(len(self.lifesprites.images)):
            x = self.lifesprites.images[i].get_width() * i
            y = SCREENHEIGHT - self.lifesprites.images[i].get_height()
            self.screen.blit(self.lifesprites.images[i], (x, y))

        for i in range(len(self.fruitCaptured)):
            x = SCREENWIDTH - self.fruitCaptured[i].get_width() * (i+1)
            y = SCREENHEIGHT - self.fruitCaptured[i].get_height()
            self.screen.blit(self.fruitCaptured[i], (x, y))

        pygame.display.update()


if __name__ == "__main__":
    game = GameController()
    game.startScreen()
    game.startScreen2()
    game.startGame()
    
    while game.running:   
        game.update()



        /////////////////////////////////////
        ////////////




        /////////////////////
        import pygame #khởi tạo pygame
from pygame.locals import * # import các hằng số như QUIT, KEYDOWN, K_SPACE, K_UP, K_DOWN, K_LEFT, K_RIGHT
from constants import * # import các hằng số cố định cho game
from sys import * # import các hàm và biến môi trường của hệ điều hành
from pacman import Pacman # import class Pacman 
from nodes import NodeGroup # import class NodeGroup
from pellets import PelletGroup # import class PelletGroup
from ghosts import GhostGroup # import class GhostGroup
from fruit import Fruit # import class Fruit
from pauser import Pause # import class Pause
from text import TextGroup # import class TextGroup 
from sprites import LifeSprites # import class LifeSprites
from sprites import MazeSprites # import class MazeSprites
from mazedata import MazeData # import class MazeData

class GameController(object): # lớp điều khiển GameController
    def __init__(self): # hàm khởi tạo
        pygame.init() # khởi tạo pygame
        pygame.mixer.init() # khởi tạo mixer để chơi nhạc
        self.screen = pygame.display.set_mode(SCREENSIZE, 0, 32) # tạo ra cửa sổ với kích thước SCREENSIZE, 0 là độ sâu màu, 32 là số bit cho mỗi pixel
        self.background = None # biến lưu trữ background
        self.background_norm = None # biến lưu trữ background bình thường
        self.background_flash = None # biến lưu trữ background flash
        self.clock = pygame.time.Clock() # biến lưu trữ đồng hồ đếm thời gian
        self.fruit = None # biến lưu trữ trái cây
        self.pause = Pause(True) # biến lưu trữ trạng thái tạm dừng
        self.level = 0 # biến lưu trữ level
        self.lives = 8 # biến lưu trữ số mạng
        self.score = 0 # biến lưu trữ điểm số
        self.textgroup = TextGroup() # biến lưu trữ textgroup
        self.lifesprites = LifeSprites(self.lives) # biến lưu trữ lifesprites
        self.flashBG = False # biến lưu trữ trạng thái flash background
        self.flashTime = 0.2 # biến lưu trữ thời gian flash
        self.flashTimer = 0 # biến lưu trữ đồng hồ đếm thời gian flash
        self.fruitCaptured = [] # biến lưu trữ trái cây đã ăn
        self.fruitNode = None # biến lưu trữ node của trái cây
        self.mazedata = MazeData() # biến lưu trữ mazedata
        self.running = True # biến lưu trữ trạng thái chạy
        self.high_score = 0 # biến lưu trữ điểm số cao nhất
    
        

    def setBackground(self): # hàm tạo background, khi qua màn thì sẽ flash flash rồi qua màn mới
        self.background_norm = pygame.surface.Surface(SCREENSIZE).convert() # tạo ra nền
        self.background_norm.fill(OPTIONAL) # tô màu nền bằng màu OPTIONAL trong Constants.py
        self.background_flash = pygame.surface.Surface(SCREENSIZE).convert() # tạo ra background flash
        self.background_flash.fill(BLACK) # tô màu background flash bằng màu đen
        self.background_norm = self.mazesprites.constructBackground(self.background_norm, self.level%5) # tạo maze
        self.background_flash = self.mazesprites.constructBackground(self.background_flash, 5) # tạo maze flash
        self.flashBG = False #flash background ban đầu ở trạng thái palse
        self.background = self.background_norm # background mặc định là background bình thường
        
    
    def startScreen(self): # Màn hình đầu tiên giới thiệu đồ án
        
        while self.running: # vòng lặp chạy khi trạng thái chạy là True
            for event in pygame.event.get(): # vòng lặp sự kiện
                if event.type == pygame.QUIT:  # Nếu người chơi nhấn nút thoát thì đóng cửa sổ
                    self.running = False
                if event.type == pygame.KEYDOWN: # Nếu người chơi nhấn một phím bất kỳ
                    if event.key == pygame.K_SPACE: # Nếu người chơi nhấn phím Space thì chuyển sang màn hình tiếp theo
                        return

            self.screen.fill((0, 250, 255)) # Tô màu nền màn hình bằng màu xanh dương
            font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 28) # Tạo font chữ với font UVN.TTF, kích thước 28
            
            instructions = ["ĐỒ ÁN CUỐI KỲ DSA","GAME PACMAN","Nguyễn Thiên Bảo","Nhấn Space để tiếp tục"]
            for i, instruction in enumerate(instructions): # Vòng lặp để in ra các dòng chữ
                instruction_text = font.render(instruction, 1, (255, 20, 100)) # Cài màu cho chữ
                instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/5 + 60 * (i+1)) # Cài vị trí cho chữ
                self.screen.blit(instruction_text, instruction_pos) # In chữ ra màn hình
            
            pygame.display.flip() # Cập nhật màn hình
            
    def startScreen2(self): # Màn hình chọn nhạc và hướng dẫn chơi
        
        self.music_options = [ "Pacman_NgThienBao/BTS_FAKELOVE.mp3", # Danh sách nhạc
                               "Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3",
                               "Pacman_NgThienBao/CAUSEILOVEYOU.mp3",
                               "Pacman_NgThienBao/HARUHARU.mp3",
                               "Pacman_NgThienBao/XICHLINH.mp3",
                               "Pacman_NgThienBao/ATTACKONTITAN1.mp3",
                               "Pacman_NgThienBao/5CMS.mp3"]
        self.music_option_names = ["[Fake Love Orchestral]", # Danh sách tên nhạc
                                   "[Buông Đôi Tay Nhau Ra]",
                                   "[Cause I Love You]",
                                   "[BigBang-Haru Haru]",
                                   "[Xích Linh Remix]",
                                   "[Attack On Titan]",
                                   "[5 Cm/s]"]
        self.music_option_texts = [] # Danh sách lưu trữ các lựa chọn nhạc
        
        font = pygame.font.Font("Pacman_NgThienBao/UVN.TTF", 20)

        instructions = ["Click chuột để chọn nhạc, có thể không chọn", "Nhấn Space để chơi và tạm dừng", "Giữ nút mũi tên để di chuyển"]
        # Khởi tạo một danh sách để lưu trữ trạng thái của từng lựa chọn nhạc
        self.music_option_states = [False] * len(self.music_option_names) 
        
        for i, instruction in enumerate(instructions): # Vòng lặp để in ra các dòng hướng dẫn
            instruction_text = font.render(instruction, 1, (255, 255, 255)) # Cài màu cho chữ
            instruction_pos = instruction_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * i)
            self.music_option_texts.append((instruction_text, instruction_pos))
        
        for i, music_option_name in enumerate(self.music_option_names): # Vòng lặp để in ra các lựa chọn nhạc
            music_option_text = font.render(music_option_name, 1, (0, 255, 255))
            music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (i+ len(instructions)))
            self.music_option_texts.append((music_option_text, music_option_pos))
            
        high_score_text = font.render(f"Highest Score: {self.high_score}", 1, (100, 255, 100)) # In ra điểm số cao nhất
        high_score_pos = high_score_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (len(self.music_option_names) + len(instructions)))
        self.music_option_texts.append((high_score_text, high_score_pos)) 
        # mượn tạm danh sách chọn nhạc để lưu trữ điểm số cao nhất
        
        while self.running: # Vòng lặp chạy khi trạng thái chạy là True
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
        
                # Trong vòng lặp sự kiện, khi người chơi click chuột:
                if event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = pygame.mouse.get_pos() # Lấy vị trí chuột
                    for i, (music_option_text, music_option_pos) in enumerate(self.music_option_texts[len(instructions):]):
                        if music_option_pos.collidepoint(x, y):
                            if i < len(self.music_options):  # Kiểm tra xem người dùng có click vào một tùy chọn nhạc hay không
                                pygame.mixer.music.load(self.music_options[i]) # Nếu có thì load nhạc thứ i trong danh sách
                                pygame.mixer.music.set_volume(1)
                                pygame.mixer.music.play(-1)
                                # Đặt trạng thái của tất cả các lựa chọn nhạc thành False
                                self.music_option_states = [False] * len(self.music_option_names) 
                                # Đặt trạng thái của lựa chọn nhạc này thành True
                                self.music_option_states[i] = True
                                # Cập nhật màu sắc của tất cả các lựa chọn nhạc
                                for j, music_option_name in enumerate(self.music_option_names): 
                                    color = YELLOW if self.music_option_states[j] else (0, 255, 255) # Nếu chọn nhạc mày thì màu sắc là màu vàng, ngược lại là màu xanh dương
                                    music_option_text = font.render(music_option_name, 1, color) # Cài màu cho chữ được chọn
                                    music_option_pos = music_option_text.get_rect(centerx=self.screen.get_width()/2 , centery=self.screen.get_height()/10 + 40 * (j+ len(instructions)))
                                    self.music_option_texts[j + len(instructions)] = (music_option_text, music_option_pos)
        
                if event.type == pygame.KEYDOWN: # Nếu người chơi nhấn một phím bất kỳ
                    if event.key == pygame.K_SPACE: # Nếu người chơi nhấn phím Space thì chuyển sang màn hình tiếp theo
                        if not pygame.mixer.music.get_busy():  # Kiểm tra xem có nhạc đang chạy không
                            pygame.mixer.music.load(self.music_options[0])  # Ko chọn thì mặc định chạy nhạc thứ nhất
                            pygame.mixer.music.set_volume(0) # Đặt âm lượng nhạc thành 0 để không có âm thanh đồng thời tránh bị lỗi chọn nhạc
                            pygame.mixer.music.play(-1)
                        return   

            self.screen.fill((OPTIONAL)) # Tô màu nền màn hình bằng OPTIONAL

            for music_option_text, music_option_pos in self.music_option_texts:
                self.screen.blit(music_option_text, music_option_pos) # In ra màn hình các lựa chọn nhạc

            pygame.display.flip() # Cập nhật màn hình
        
    


    def startGame(self): # Hàm bắt đầu game
            
        self.mazedata.loadMaze(self.level) 
        self.mazesprites = MazeSprites(self.mazedata.obj.name+".txt", self.mazedata.obj.name+"_rotation.txt")
        self.setBackground()
        self.nodes = NodeGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.mazedata.obj.setPortalPairs(self.nodes)
        self.mazedata.obj.connectHomeNodes(self.nodes)
        self.pacman = Pacman(self.nodes.getNodeFromTiles(*self.mazedata.obj.pacmanStart)) 
        self.pellets = PelletGroup("Pacman_NgThienBao/" + self.mazedata.obj.name+".txt")
        self.ghosts = GhostGroup(self.nodes.getStartTempNode(), self.pacman)

        self.ghosts.pinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.inky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(0, 3)))
        self.ghosts.clyde.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(4, 3)))
        self.ghosts.setSpawnNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 3)))
        self.ghosts.blinky.setStartNode(self.nodes.getNodeFromTiles(*self.mazedata.obj.addOffset(2, 0)))

        self.nodes.denyHomeAccess(self.pacman)
        self.nodes.denyHomeAccessList(self.ghosts)
        self.ghosts.inky.startNode.denyAccess(RIGHT, self.ghosts.inky)
        self.ghosts.clyde.startNode.denyAccess(LEFT, self.ghosts.clyde)
        self.mazedata.obj.denyGhostsAccess(self.ghosts, self.nodes)
 
    def update(self): # Hàm cập nhật game, về cơ bản là vòng lặp trò chơi
        dt = self.clock.tick(30) / 800.0 #Đồng hồ cho việc cập nhật 
        self.textgroup.update(dt)
        self.pellets.update(dt)
        if not self.pause.paused:
            self.ghosts.update(dt)      
            if self.fruit is not None:
                self.fruit.update(dt)
            self.checkPelletEvents()
            self.checkGhostEvents()
            self.checkFruitEvents()

        if self.pacman.alive:
            if not self.pause.paused:
                self.pacman.update(dt)
        else:
            self.pacman.update(dt)

        if self.flashBG:
            self.flashTimer += dt
            if self.flashTimer >= self.flashTime:
                self.flashTimer = 0
                if self.background == self.background_norm:
                    self.background = self.background_flash
                else:
                    self.background = self.background_norm

        afterPauseMethod = self.pause.update(dt)
        if afterPauseMethod is not None:
            afterPauseMethod()
        self.checkEvents()
        self.render()

    def checkEvents(self): # Hàm kiểm tra sự kiện
        for event in pygame.event.get(): 
            if event.type == QUIT:  # Nếu người chơi nhấn nút thoát thì đóng cửa sổ
                exit() 
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    if self.pacman.alive:
                        self.pause.setPause(playerPaused=True)
                        if not self.pause.paused:
                            self.textgroup.hideText()
                            self.showEntities()
                        else:
                            self.textgroup.showText(PAUSETXT)
                            #self.hideEntities()

    def checkPelletEvents(self): # Hàm kiểm tra Pacman ăn pellet
        pellet = self.pacman.eatPellets(self.pellets.pelletList)
        if pellet:
            self.pellets.numEaten += 1
            self.updateScore(pellet.points)
            if self.pellets.numEaten == 30:
                self.ghosts.inky.startNode.allowAccess(RIGHT, self.ghosts.inky)
            if self.pellets.numEaten == 70:
                self.ghosts.clyde.startNode.allowAccess(LEFT, self.ghosts.clyde)
            self.pellets.pelletList.remove(pellet)
            if pellet.name == POWERPELLET: #Nếu ăn được power pellet thì nhạc hiệu ứng nổi lên, và ghost chuyển sang trạng thái Freight
                effect_sound = pygame.mixer.Sound("Pacman_NgThienBao/WAKUWAKU.mp3")
                effect_sound.play()
                self.ghosts.startFreight()
            if self.pellets.isEmpty(): #Nếu ăn hết pellet thì hiện hiệu ứng flash background và qua màn mới
                self.flashBG = True
                self.hideEntities()
                self.pause.setPause(pauseTime=3, func=self.nextLevel)
                
              
    def checkGhostEvents(self): #Hàm kiểm tra xem Pacman có va chạm với Ghost hay không
        for ghost in self.ghosts:
            if self.pacman.collideGhost(ghost):
                if ghost.mode.current is FREIGHT:
                    effect_sound = pygame.mixer.Sound("Pacman_NgThienBao/WAKUWAKU.mp3")
                    effect_sound.play()
                    
                    self.pacman.visible = False
                    ghost.visible = False
                    self.updateScore(ghost.points)                  
                    self.textgroup.addText(str(ghost.points), WHITE, ghost.position.x, ghost.position.y, 8, time=1)
                    self.ghosts.updatePoints()
                    self.pause.setPause(pauseTime=1, func=self.showEntities)
                    ghost.startSpawn()
                    self.nodes.allowHomeAccess(ghost)
                elif ghost.mode.current is not SPAWN:
                    if self.pacman.alive:
                        self.lives -=  1
                        self.lifesprites.removeImage()
                        self.pacman.die()               
                        self.ghosts.hide()
                        effect_sound = pygame.mixer.Sound("Pacman_NgThienBao/WAKUWAKU.mp3")
                        effect_sound.play()
                        if self.lives <= 0: #Nếu hết mạng thì gameover từ đây
                            pygame.mixer.music.stop()
                            self.textgroup.showText(GAMEOVERTXT)
                            self.pause.setPause(pauseTime=3, func=self.restartGame)
                            self.high_score = max(self.score, self.high_score)
                        else:
                            self.pause.setPause(pauseTime=3, func=self.resetLevel)
                            
        
    def checkFruitEvents(self): #Hàm kiểm tra xem Pacman có ăn được trái cây hay không
        if self.pellets.numEaten == 50 or self.pellets.numEaten == 140:
            if self.fruit is None:
                self.fruit = Fruit(self.nodes.getNodeFromTiles(9, 20), self.level)
                print(self.fruit)
        if self.fruit is not None:
            if self.pacman.collideCheck(self.fruit):
                self.updateScore(self.fruit.points)
                self.textgroup.addText(str(self.fruit.points), WHITE, self.fruit.position.x, self.fruit.position.y, 8, time=1)
                fruitCaptured = False
                for fruit in self.fruitCaptured:
                    if fruit.get_offset() == self.fruit.image.get_offset():
                        fruitCaptured = True
                        break
                if not fruitCaptured:
                    self.fruitCaptured.append(self.fruit.image)
                self.fruit = None
            elif self.fruit.destroy:
                self.fruit = None

    def showEntities(self): #Hàm hiện thực thể
        self.pacman.visible = True
        self.ghosts.show()

    def hideEntities(self): #Hàm ẩn thực thể
        self.pacman.visible = False
        self.ghosts.hide()

    def nextLevel(self): #Hàm qua màn mới
        self.showEntities()
        self.level += 1
        self.pause.paused = True
        self.startGame()
        self.textgroup.updateLevel(self.level)

    def restartGame(self): #Hàm restart lại game, được gọi khi chơi lại các lần kế tiếp
        #pygame.mixer.music.load("Pacman_NgThienBao/BUONGDOITAYNHAURA.mp3")
        self.startScreen2()
        self.lives = 8
        self.level = 0
        self.pause.paused = True
        self.fruit = None
        self.startGame()
        self.score = 0
        self.textgroup.updateScore(self.score)
        self.textgroup.updateLevel(self.level)
        self.textgroup.showText(READYTXT)
        self.lifesprites.resetLives(self.lives)
        self.fruitCaptured = []

    def resetLevel(self): #Hàm reset lại màn chơi
        self.pause.paused = True
        self.pacman.reset()
        self.ghosts.reset()
        self.fruit = None
        self.textgroup.showText(READYTXT)

    def updateScore(self, points): #Hàm cập nhật điểm số
        self.score += points
        self.textgroup.updateScore(self.score)

    def render(self): #Hàm vẽ các thực thể ra màn hình
        self.screen.blit(self.background, (0, 0))
        #self.nodes.render(self.screen)
        self.pellets.render(self.screen)
        if self.fruit is not None:
            self.fruit.render(self.screen)
        self.pacman.render(self.screen)
        self.ghosts.render(self.screen)
        self.textgroup.render(self.screen)

        for i in range(len(self.lifesprites.images)):
            x = self.lifesprites.images[i].get_width() * i
            y = SCREENHEIGHT - self.lifesprites.images[i].get_height()
            self.screen.blit(self.lifesprites.images[i], (x, y))

        for i in range(len(self.fruitCaptured)):
            x = SCREENWIDTH - self.fruitCaptured[i].get_width() * (i+1)
            y = SCREENHEIGHT - self.fruitCaptured[i].get_height()
            self.screen.blit(self.fruitCaptured[i], (x, y))

        pygame.display.update()


if __name__ == "__main__": # Hàm main
    game = GameController()
    game.startScreen()
    game.startScreen2()
    game.startGame()
    
    while game.running:   
        game.update()